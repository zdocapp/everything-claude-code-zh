{
  "sourceFile": "commands/plan.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\ndescription: Restate requirements, assess risks, and create step-by-step implementation plan. WAIT for user CONFIRM before touching any code.\n---",
      "zh-Hans": "---\ndescription: 重新阐述需求、评估风险并创建分步实施计划。在接触任何代码之前，等待用户确认。\n---"
    },
    {
      "en-US": "# Plan Command",
      "zh-Hans": "# 计划命令"
    },
    {
      "en-US": "This command invokes the **planner** agent to create a comprehensive implementation plan before writing any code.",
      "zh-Hans": "此命令调用 **planner** 代理，在编写任何代码之前创建一个全面的实施计划。"
    },
    {
      "en-US": "## What This Command Does",
      "zh-Hans": "## 此命令的作用"
    },
    {
      "en-US": "1. **Restate Requirements** - Clarify what needs to be built\n2. **Identify Risks** - Surface potential issues and blockers\n3. **Create Step Plan** - Break down implementation into phases\n4. **Wait for Confirmation** - MUST receive user approval before proceeding",
      "zh-Hans": "1. **重新阐述需求** - 明确需要构建什么\n2. **识别风险** - 揭示潜在问题和阻碍\n3. **创建分步计划** - 将实施分解为多个阶段\n4. **等待确认** - 必须获得用户批准才能继续"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "Use `/plan` when:",
      "zh-Hans": "在以下情况下使用 `/plan`："
    },
    {
      "en-US": "- Starting a new feature\n- Making significant architectural changes\n- Working on complex refactoring\n- Multiple files/components will be affected\n- Requirements are unclear or ambiguous",
      "zh-Hans": "* 开始新功能时\n* 进行重大架构变更时\n* 处理复杂重构时\n* 多个文件/组件将受到影响时\n* 需求不明确或存在歧义时"
    },
    {
      "en-US": "## How It Works",
      "zh-Hans": "## 工作原理"
    },
    {
      "en-US": "The planner agent will:",
      "zh-Hans": "planner 代理将："
    },
    {
      "en-US": "1. **Analyze the request** and restate requirements in clear terms\n2. **Break down into phases** with specific, actionable steps\n3. **Identify dependencies** between components\n4. **Assess risks** and potential blockers\n5. **Estimate complexity** (High/Medium/Low)\n6. **Present the plan** and WAIT for your explicit confirmation",
      "zh-Hans": "1. **分析请求** 并用清晰的术语重新阐述需求\n2. **分解为多个阶段**，每个阶段包含具体、可操作的步骤\n3. **识别组件之间的依赖关系**\n4. **评估风险和潜在阻碍**\n5. **估算复杂度**（高/中/低）\n6. **展示计划**并等待您明确的确认"
    },
    {
      "en-US": "## Example Usage",
      "zh-Hans": "## 使用示例"
    },
    {
      "en-US": "```\nUser: /plan I need to add real-time notifications when markets resolve\n\nAgent (planner):\n# Implementation Plan: Real-Time Market Resolution Notifications\n\n## Requirements Restatement\n- Send notifications to users when markets they're watching resolve\n- Support multiple notification channels (in-app, email, webhook)\n- Ensure notifications are delivered reliably\n- Include market outcome and user's position result\n\n## Implementation Phases\n\n### Phase 1: Database Schema\n- Add notifications table with columns: id, user_id, market_id, type, status, created_at\n- Add user_notification_preferences table for channel preferences\n- Create indexes on user_id and market_id for performance\n\n### Phase 2: Notification Service\n- Create notification service in lib/notifications.ts\n- Implement notification queue using BullMQ/Redis\n- Add retry logic for failed deliveries\n- Create notification templates\n\n### Phase 3: Integration Points\n- Hook into market resolution logic (when status changes to \"resolved\")\n- Query all users with positions in market\n- Enqueue notifications for each user\n\n### Phase 4: Frontend Components\n- Create NotificationBell component in header\n- Add NotificationList modal\n- Implement real-time updates via Supabase subscriptions\n- Add notification preferences page\n\n## Dependencies\n- Redis (for queue)\n- Email service (SendGrid/Resend)\n- Supabase real-time subscriptions\n\n## Risks\n- HIGH: Email deliverability (SPF/DKIM required)\n- MEDIUM: Performance with 1000+ users per market\n- MEDIUM: Notification spam if markets resolve frequently\n- LOW: Real-time subscription overhead\n\n## Estimated Complexity: MEDIUM\n- Backend: 4-6 hours\n- Frontend: 3-4 hours\n- Testing: 2-3 hours\n- Total: 9-13 hours\n\n**WAITING FOR CONFIRMATION**: Proceed with this plan? (yes/no/modify)\n```",
      "zh-Hans": "```\nUser: /plan I need to add real-time notifications when markets resolve\n\nAgent (planner):\n# Implementation Plan: Real-Time Market Resolution Notifications\n\n## Requirements Restatement\n- Send notifications to users when markets they're watching resolve\n- Support multiple notification channels (in-app, email, webhook)\n- Ensure notifications are delivered reliably\n- Include market outcome and user's position result\n\n## Implementation Phases\n\n### Phase 1: Database Schema\n- Add notifications table with columns: id, user_id, market_id, type, status, created_at\n- Add user_notification_preferences table for channel preferences\n- Create indexes on user_id and market_id for performance\n\n### Phase 2: Notification Service\n- Create notification service in lib/notifications.ts\n- Implement notification queue using BullMQ/Redis\n- Add retry logic for failed deliveries\n- Create notification templates\n\n### Phase 3: Integration Points\n- Hook into market resolution logic (when status changes to \"resolved\")\n- Query all users with positions in market\n- Enqueue notifications for each user\n\n### Phase 4: Frontend Components\n- Create NotificationBell component in header\n- Add NotificationList modal\n- Implement real-time updates via Supabase subscriptions\n- Add notification preferences page\n\n## Dependencies\n- Redis (for queue)\n- Email service (SendGrid/Resend)\n- Supabase real-time subscriptions\n\n## Risks\n- HIGH: Email deliverability (SPF/DKIM required)\n- MEDIUM: Performance with 1000+ users per market\n- MEDIUM: Notification spam if markets resolve frequently\n- LOW: Real-time subscription overhead\n\n## Estimated Complexity: MEDIUM\n- Backend: 4-6 hours\n- Frontend: 3-4 hours\n- Testing: 2-3 hours\n- Total: 9-13 hours\n\n**WAITING FOR CONFIRMATION**: Proceed with this plan? (yes/no/modify)\n```"
    },
    {
      "en-US": "## Important Notes",
      "zh-Hans": "## 重要说明"
    },
    {
      "en-US": "**CRITICAL**: The planner agent will **NOT** write any code until you explicitly confirm the plan with \"yes\" or \"proceed\" or similar affirmative response.",
      "zh-Hans": "**关键**：planner 代理在您明确用“是”、“继续”或类似的肯定性答复确认计划之前，**不会**编写任何代码。"
    },
    {
      "en-US": "If you want changes, respond with:",
      "zh-Hans": "如果您希望修改，请回复："
    },
    {
      "en-US": "- \"modify: [your changes]\"\n- \"different approach: [alternative]\"\n- \"skip phase 2 and do phase 3 first\"",
      "zh-Hans": "* \"修改：\\[您的修改内容]\"\n* \"不同方法：\\[替代方案]\"\n* \"跳过阶段 2，先执行阶段 3\""
    },
    {
      "en-US": "## Integration with Other Commands",
      "zh-Hans": "## 与其他命令的集成"
    },
    {
      "en-US": "After planning:",
      "zh-Hans": "计划之后："
    },
    {
      "en-US": "- Use `/tdd` to implement with test-driven development\n- Use `/build-and-fix` if build errors occur\n- Use `/code-review` to review completed implementation",
      "zh-Hans": "* 使用 `/tdd` 以测试驱动开发的方式实施\n* 如果出现构建错误，使用 `/build-and-fix`\n* 使用 `/code-review` 审查已完成的实施"
    },
    {
      "en-US": "## Related Agents",
      "zh-Hans": "## 相关代理"
    },
    {
      "en-US": "This command invokes the `planner` agent located at:\n`~/.claude/agents/planner.md`",
      "zh-Hans": "此命令调用位于 `~/.claude/agents/planner.md` 的 `planner` 代理。"
    }
  ]
}