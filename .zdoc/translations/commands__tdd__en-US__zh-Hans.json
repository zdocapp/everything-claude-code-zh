{
  "sourceFile": "commands/tdd.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\ndescription: Enforce test-driven development workflow. Scaffold interfaces, generate tests FIRST, then implement minimal code to pass. Ensure 80%+ coverage.\n---",
      "zh-Hans": "---\ndescription: 强制执行测试驱动开发工作流。首先搭建接口，生成测试，然后实现最小化代码以通过测试。确保 80%+ 覆盖率。\n---"
    },
    {
      "en-US": "# TDD Command",
      "zh-Hans": "# TDD 命令"
    },
    {
      "en-US": "This command invokes the **tdd-guide** agent to enforce test-driven development methodology.",
      "zh-Hans": "此命令调用 **tdd-guide** 代理来强制执行测试驱动开发方法。"
    },
    {
      "en-US": "## What This Command Does",
      "zh-Hans": "## 此命令的作用"
    },
    {
      "en-US": "1. **Scaffold Interfaces** - Define types/interfaces first\n2. **Generate Tests First** - Write failing tests (RED)\n3. **Implement Minimal Code** - Write just enough to pass (GREEN)\n4. **Refactor** - Improve code while keeping tests green (REFACTOR)\n5. **Verify Coverage** - Ensure 80%+ test coverage",
      "zh-Hans": "1. **搭建接口** - 首先定义类型/接口\n2. **首先生成测试** - 编写失败的测试（红）\n3. **实现最小化代码** - 编写刚好足够的代码以通过测试（绿）\n4. **重构** - 改进代码，同时保持测试通过（重构）\n5. **验证覆盖率** - 确保 80%+ 的测试覆盖率"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "Use `/tdd` when:",
      "zh-Hans": "在以下情况下使用 `/tdd`："
    },
    {
      "en-US": "- Implementing new features\n- Adding new functions/components\n- Fixing bugs (write test that reproduces bug first)\n- Refactoring existing code\n- Building critical business logic",
      "zh-Hans": "* 实现新功能时\n* 添加新函数/组件时\n* 修复错误时（首先编写重现错误的测试）\n* 重构现有代码时\n* 构建关键业务逻辑时"
    },
    {
      "en-US": "## How It Works",
      "zh-Hans": "## 工作原理"
    },
    {
      "en-US": "The tdd-guide agent will:",
      "zh-Hans": "tdd-guide 代理将："
    },
    {
      "en-US": "1. **Define interfaces** for inputs/outputs\n2. **Write tests that will FAIL** (because code doesn't exist yet)\n3. **Run tests** and verify they fail for the right reason\n4. **Write minimal implementation** to make tests pass\n5. **Run tests** and verify they pass\n6. **Refactor** code while keeping tests green\n7. **Check coverage** and add more tests if below 80%",
      "zh-Hans": "1. 为输入/输出**定义接口**\n2. **编写将会失败的测试**（因为代码尚不存在）\n3. **运行测试**并验证它们因正确的原因而失败\n4. **编写最小化实现**以使测试通过\n5. **运行测试**并验证它们通过\n6. **重构**代码，同时保持测试通过\n7. **检查覆盖率**，如果低于 80% 则添加更多测试"
    },
    {
      "en-US": "## TDD Cycle",
      "zh-Hans": "## TDD 循环"
    },
    {
      "en-US": "```\nRED → GREEN → REFACTOR → REPEAT\n\nRED:      Write a failing test\nGREEN:    Write minimal code to pass\nREFACTOR: Improve code, keep tests passing\nREPEAT:   Next feature/scenario\n```",
      "zh-Hans": "```\nRED → GREEN → REFACTOR → REPEAT\n\nRED:      Write a failing test\nGREEN:    Write minimal code to pass\nREFACTOR: Improve code, keep tests passing\nREPEAT:   Next feature/scenario\n```"
    },
    {
      "en-US": "## Example Usage",
      "zh-Hans": "## 使用示例"
    },
    {
      "en-US": "```\nUser: /tdd I need a function to calculate market liquidity score\n\nAgent (tdd-guide):\n# TDD Session: Market Liquidity Score Calculator\n\n## Step 1: Define Interface (SCAFFOLD)\n\n```typescript\n// lib/liquidity.ts\nexport interface MarketData {\n  totalVolume: number\n  bidAskSpread: number\n  activeTraders: number\n  lastTradeTime: Date\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  // TODO: Implementation\n  throw new Error('Not implemented')\n}\n```",
      "zh-Hans": "````\nUser: /tdd I need a function to calculate market liquidity score\n\nAgent (tdd-guide):\n# TDD Session: Market Liquidity Score Calculator\n\n## Step 1: Define Interface (SCAFFOLD)\n\n```typescript\n// lib/liquidity.ts\nexport interface MarketData {\n  totalVolume: number\n  bidAskSpread: number\n  activeTraders: number\n  lastTradeTime: Date\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  // TODO: Implementation\n  throw new Error('Not implemented')\n}\n````"
    },
    {
      "en-US": "## Step 2: Write Failing Test (RED)",
      "zh-Hans": "## 步骤 2：编写失败的测试（红）"
    },
    {
      "en-US": "```typescript\n// lib/liquidity.test.ts\nimport { calculateLiquidityScore } from './liquidity'\n\ndescribe('calculateLiquidityScore', () => {\n  it('should return high score for liquid market', () => {\n    const market = {\n      totalVolume: 100000,\n      bidAskSpread: 0.01,\n      activeTraders: 500,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeGreaterThan(80)\n    expect(score).toBeLessThanOrEqual(100)\n  })\n\n  it('should return low score for illiquid market', () => {\n    const market = {\n      totalVolume: 100,\n      bidAskSpread: 0.5,\n      activeTraders: 2,\n      lastTradeTime: new Date(Date.now() - 86400000) // 1 day ago\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeLessThan(30)\n    expect(score).toBeGreaterThanOrEqual(0)\n  })\n\n  it('should handle edge case: zero volume', () => {\n    const market = {\n      totalVolume: 0,\n      bidAskSpread: 0,\n      activeTraders: 0,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBe(0)\n  })\n})\n```",
      "zh-Hans": "```typescript\n// lib/liquidity.test.ts\nimport { calculateLiquidityScore } from './liquidity'\n\ndescribe('calculateLiquidityScore', () => {\n  it('should return high score for liquid market', () => {\n    const market = {\n      totalVolume: 100000,\n      bidAskSpread: 0.01,\n      activeTraders: 500,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeGreaterThan(80)\n    expect(score).toBeLessThanOrEqual(100)\n  })\n\n  it('should return low score for illiquid market', () => {\n    const market = {\n      totalVolume: 100,\n      bidAskSpread: 0.5,\n      activeTraders: 2,\n      lastTradeTime: new Date(Date.now() - 86400000) // 1 day ago\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeLessThan(30)\n    expect(score).toBeGreaterThanOrEqual(0)\n  })\n\n  it('should handle edge case: zero volume', () => {\n    const market = {\n      totalVolume: 0,\n      bidAskSpread: 0,\n      activeTraders: 0,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBe(0)\n  })\n})\n```"
    },
    {
      "en-US": "## Step 3: Run Tests - Verify FAIL",
      "zh-Hans": "## 步骤 3：运行测试 - 验证失败"
    },
    {
      "en-US": "```bash\nnpm test lib/liquidity.test.ts\n\nFAIL lib/liquidity.test.ts\n  ✕ should return high score for liquid market (2 ms)\n    Error: Not implemented\n\n1 test failed, 0 passed\n```",
      "zh-Hans": "```bash\nnpm test lib/liquidity.test.ts\n\nFAIL lib/liquidity.test.ts\n  ✕ should return high score for liquid market (2 ms)\n    Error: Not implemented\n\n1 test failed, 0 passed\n```"
    },
    {
      "en-US": "✅ Tests fail as expected. Ready to implement.",
      "zh-Hans": "✅ 测试按预期失败。准备实施。"
    },
    {
      "en-US": "## Step 4: Implement Minimal Code (GREEN)",
      "zh-Hans": "## 步骤 4：实现最小化代码（绿）"
    },
    {
      "en-US": "```typescript\n// lib/liquidity.ts\nexport function calculateLiquidityScore(market: MarketData): number {\n  // Handle zero volume edge case\n  if (market.totalVolume === 0) {\n    return 0\n  }\n\n  // Calculate component scores (0-100 scale)\n  const volumeScore = Math.min(market.totalVolume / 1000, 100)\n  const spreadScore = Math.max(100 - (market.bidAskSpread * 1000), 0)\n  const traderScore = Math.min(market.activeTraders / 10, 100)\n\n  // Recent activity bonus\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = Math.max(100 - (hoursSinceLastTrade * 10), 0)\n\n  // Weighted average\n  const score = (\n    volumeScore * 0.4 +\n    spreadScore * 0.3 +\n    traderScore * 0.2 +\n    recencyScore * 0.1\n  )\n\n  return Math.min(Math.max(score, 0), 100) // Clamp to 0-100\n}\n```",
      "zh-Hans": "```typescript\n// lib/liquidity.ts\nexport function calculateLiquidityScore(market: MarketData): number {\n  // Handle zero volume edge case\n  if (market.totalVolume === 0) {\n    return 0\n  }\n\n  // Calculate component scores (0-100 scale)\n  const volumeScore = Math.min(market.totalVolume / 1000, 100)\n  const spreadScore = Math.max(100 - (market.bidAskSpread * 1000), 0)\n  const traderScore = Math.min(market.activeTraders / 10, 100)\n\n  // Recent activity bonus\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = Math.max(100 - (hoursSinceLastTrade * 10), 0)\n\n  // Weighted average\n  const score = (\n    volumeScore * 0.4 +\n    spreadScore * 0.3 +\n    traderScore * 0.2 +\n    recencyScore * 0.1\n  )\n\n  return Math.min(Math.max(score, 0), 100) // Clamp to 0-100\n}\n```"
    },
    {
      "en-US": "## Step 5: Run Tests - Verify PASS",
      "zh-Hans": "## 步骤 5：运行测试 - 验证通过"
    },
    {
      "en-US": "```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ✓ should return high score for liquid market (3 ms)\n  ✓ should return low score for illiquid market (2 ms)\n  ✓ should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```",
      "zh-Hans": "```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ✓ should return high score for liquid market (3 ms)\n  ✓ should return low score for illiquid market (2 ms)\n  ✓ should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```"
    },
    {
      "en-US": "✅ All tests passing!",
      "zh-Hans": "✅ 所有测试通过！"
    },
    {
      "en-US": "## Step 6: Refactor (IMPROVE)",
      "zh-Hans": "## 步骤 6：重构（改进）"
    },
    {
      "en-US": "```typescript\n// lib/liquidity.ts - Refactored with constants and better readability\nconst WEIGHTS = {\n  VOLUME: 0.4,\n  SPREAD: 0.3,\n  TRADERS: 0.2,\n  RECENCY: 0.1,\n} as const\n\nconst SCALE_FACTORS = {\n  VOLUME: 1000,\n  SPREAD: 1000,\n  TRADERS: 10,\n  RECENCY_PENALTY: 10,\n} as const\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  if (market.totalVolume === 0) return 0\n\n  const volumeScore = Math.min(market.totalVolume / SCALE_FACTORS.VOLUME, 100)\n  const spreadScore = clamp(100 - (market.bidAskSpread * SCALE_FACTORS.SPREAD), 0, 100)\n  const traderScore = Math.min(market.activeTraders / SCALE_FACTORS.TRADERS, 100)\n\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = clamp(100 - (hoursSinceLastTrade * SCALE_FACTORS.RECENCY_PENALTY), 0, 100)\n\n  const weightedScore =\n    volumeScore * WEIGHTS.VOLUME +\n    spreadScore * WEIGHTS.SPREAD +\n    traderScore * WEIGHTS.TRADERS +\n    recencyScore * WEIGHTS.RECENCY\n\n  return clamp(weightedScore, 0, 100)\n}\n```",
      "zh-Hans": "```typescript\n// lib/liquidity.ts - Refactored with constants and better readability\nconst WEIGHTS = {\n  VOLUME: 0.4,\n  SPREAD: 0.3,\n  TRADERS: 0.2,\n  RECENCY: 0.1,\n} as const\n\nconst SCALE_FACTORS = {\n  VOLUME: 1000,\n  SPREAD: 1000,\n  TRADERS: 10,\n  RECENCY_PENALTY: 10,\n} as const\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  if (market.totalVolume === 0) return 0\n\n  const volumeScore = Math.min(market.totalVolume / SCALE_FACTORS.VOLUME, 100)\n  const spreadScore = clamp(100 - (market.bidAskSpread * SCALE_FACTORS.SPREAD), 0, 100)\n  const traderScore = Math.min(market.activeTraders / SCALE_FACTORS.TRADERS, 100)\n\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = clamp(100 - (hoursSinceLastTrade * SCALE_FACTORS.RECENCY_PENALTY), 0, 100)\n\n  const weightedScore =\n    volumeScore * WEIGHTS.VOLUME +\n    spreadScore * WEIGHTS.SPREAD +\n    traderScore * WEIGHTS.TRADERS +\n    recencyScore * WEIGHTS.RECENCY\n\n  return clamp(weightedScore, 0, 100)\n}\n```"
    },
    {
      "en-US": "## Step 7: Verify Tests Still Pass",
      "zh-Hans": "## 步骤 7：验证测试仍然通过"
    },
    {
      "en-US": "```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ✓ should return high score for liquid market (3 ms)\n  ✓ should return low score for illiquid market (2 ms)\n  ✓ should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```",
      "zh-Hans": "```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ✓ should return high score for liquid market (3 ms)\n  ✓ should return low score for illiquid market (2 ms)\n  ✓ should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```"
    },
    {
      "en-US": "✅ Refactoring complete, tests still passing!",
      "zh-Hans": "✅ 重构完成，测试仍然通过！"
    },
    {
      "en-US": "## Step 8: Check Coverage",
      "zh-Hans": "## 步骤 8：检查覆盖率"
    },
    {
      "en-US": "```bash\nnpm test -- --coverage lib/liquidity.test.ts\n\nFile           | % Stmts | % Branch | % Funcs | % Lines\n---------------|---------|----------|---------|--------\nliquidity.ts   |   100   |   100    |   100   |   100\n\nCoverage: 100% ✅ (Target: 80%)\n```",
      "zh-Hans": "```bash\nnpm test -- --coverage lib/liquidity.test.ts\n\nFile           | % Stmts | % Branch | % Funcs | % Lines\n---------------|---------|----------|---------|--------\nliquidity.ts   |   100   |   100    |   100   |   100\n\nCoverage: 100% ✅ (Target: 80%)\n```"
    },
    {
      "en-US": "✅ TDD session complete!",
      "zh-Hans": "✅ TDD 会话完成！"
    },
    {
      "en-US": "```\n\n## TDD Best Practices\n\n**DO:**\n- ✅ Write the test FIRST, before any implementation\n- ✅ Run tests and verify they FAIL before implementing\n- ✅ Write minimal code to make tests pass\n- ✅ Refactor only after tests are green\n- ✅ Add edge cases and error scenarios\n- ✅ Aim for 80%+ coverage (100% for critical code)\n\n**DON'T:**\n- ❌ Write implementation before tests\n- ❌ Skip running tests after each change\n- ❌ Write too much code at once\n- ❌ Ignore failing tests\n- ❌ Test implementation details (test behavior)\n- ❌ Mock everything (prefer integration tests)\n\n## Test Types to Include\n\n**Unit Tests** (Function-level):\n- Happy path scenarios\n- Edge cases (empty, null, max values)\n- Error conditions\n- Boundary values\n\n**Integration Tests** (Component-level):\n- API endpoints\n- Database operations\n- External service calls\n- React components with hooks\n\n**E2E Tests** (use `/e2e` command):\n- Critical user flows\n- Multi-step processes\n- Full stack integration\n\n## Coverage Requirements\n\n- **80% minimum** for all code\n- **100% required** for:\n  - Financial calculations\n  - Authentication logic\n  - Security-critical code\n  - Core business logic\n\n## Important Notes\n\n**MANDATORY**: Tests must be written BEFORE implementation. The TDD cycle is:\n\n1. **RED** - Write failing test\n2. **GREEN** - Implement to pass\n3. **REFACTOR** - Improve code\n\nNever skip the RED phase. Never write code before tests.\n\n## Integration with Other Commands\n\n- Use `/plan` first to understand what to build\n- Use `/tdd` to implement with tests\n- Use `/build-and-fix` if build errors occur\n- Use `/code-review` to review implementation\n- Use `/test-coverage` to verify coverage\n\n## Related Agents\n\nThis command invokes the `tdd-guide` agent located at:\n`~/.claude/agents/tdd-guide.md`\n\nAnd can reference the `tdd-workflow` skill at:\n`~/.claude/skills/tdd-workflow/`\n",
      "zh-Hans": "```\n\n## TDD Best Practices\n\n**DO:**\n- ✅ Write the test FIRST, before any implementation\n- ✅ Run tests and verify they FAIL before implementing\n- ✅ Write minimal code to make tests pass\n- ✅ Refactor only after tests are green\n- ✅ Add edge cases and error scenarios\n- ✅ Aim for 80%+ coverage (100% for critical code)\n\n**DON'T:**\n- ❌ Write implementation before tests\n- ❌ Skip running tests after each change\n- ❌ Write too much code at once\n- ❌ Ignore failing tests\n- ❌ Test implementation details (test behavior)\n- ❌ Mock everything (prefer integration tests)\n\n## Test Types to Include\n\n**Unit Tests** (Function-level):\n- Happy path scenarios\n- Edge cases (empty, null, max values)\n- Error conditions\n- Boundary values\n\n**Integration Tests** (Component-level):\n- API endpoints\n- Database operations\n- External service calls\n- React components with hooks\n\n**E2E Tests** (use `/e2e` command):\n- Critical user flows\n- Multi-step processes\n- Full stack integration\n\n## Coverage Requirements\n\n- **80% minimum** for all code\n- **100% required** for:\n  - Financial calculations\n  - Authentication logic\n  - Security-critical code\n  - Core business logic\n\n## Important Notes\n\n**MANDATORY**: Tests must be written BEFORE implementation. The TDD cycle is:\n\n1. **RED** - Write failing test\n2. **GREEN** - Implement to pass\n3. **REFACTOR** - Improve code\n\nNever skip the RED phase. Never write code before tests.\n\n## Integration with Other Commands\n\n- Use `/plan` first to understand what to build\n- Use `/tdd` to implement with tests\n- Use `/build-and-fix` if build errors occur\n- Use `/code-review` to review implementation\n- Use `/test-coverage` to verify coverage\n\n## Related Agents\n\nThis command invokes the `tdd-guide` agent located at:\n`~/.claude/agents/tdd-guide.md`\n\nAnd can reference the `tdd-workflow` skill at:\n`~/.claude/skills/tdd-workflow/`\n\n```"
    }
  ]
}