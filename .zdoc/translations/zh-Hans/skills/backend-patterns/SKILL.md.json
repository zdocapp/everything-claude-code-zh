{
  "sourceFile": "skills/backend-patterns/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: backend-patterns\ndescription: Backend architecture patterns, API design, database optimization, and server-side best practices for Node.js, Express, and Next.js API routes.\n---",
      "zh-Hans": "---\nname: backend-patterns\ndescription: 后端架构模式、API设计、数据库优化以及针对Node.js、Express和Next.js API路由的服务器端最佳实践。\n---"
    },
    {
      "en-US": "# Backend Development Patterns",
      "zh-Hans": "# 后端开发模式"
    },
    {
      "en-US": "Backend architecture patterns and best practices for scalable server-side applications.",
      "zh-Hans": "用于可扩展服务器端应用程序的后端架构模式和最佳实践。"
    },
    {
      "en-US": "## API Design Patterns",
      "zh-Hans": "## API 设计模式"
    },
    {
      "en-US": "### RESTful API Structure",
      "zh-Hans": "### RESTful API 结构"
    },
    {
      "en-US": "```typescript\n// ✅ Resource-based URLs\nGET    /api/markets                 # List resources\nGET    /api/markets/:id             # Get single resource\nPOST   /api/markets                 # Create resource\nPUT    /api/markets/:id             # Replace resource\nPATCH  /api/markets/:id             # Update resource\nDELETE /api/markets/:id             # Delete resource\n\n// ✅ Query parameters for filtering, sorting, pagination\nGET /api/markets?status=active&sort=volume&limit=20&offset=0\n```",
      "zh-Hans": "```typescript\n// ✅ Resource-based URLs\nGET    /api/markets                 # List resources\nGET    /api/markets/:id             # Get single resource\nPOST   /api/markets                 # Create resource\nPUT    /api/markets/:id             # Replace resource\nPATCH  /api/markets/:id             # Update resource\nDELETE /api/markets/:id             # Delete resource\n\n// ✅ Query parameters for filtering, sorting, pagination\nGET /api/markets?status=active&sort=volume&limit=20&offset=0\n```"
    },
    {
      "en-US": "### Repository Pattern",
      "zh-Hans": "### 仓储模式"
    },
    {
      "en-US": "```typescript\n// Abstract data access logic\ninterface MarketRepository {\n  findAll(filters?: MarketFilters): Promise<Market[]>\n  findById(id: string): Promise<Market | null>\n  create(data: CreateMarketDto): Promise<Market>\n  update(id: string, data: UpdateMarketDto): Promise<Market>\n  delete(id: string): Promise<void>\n}\n\nclass SupabaseMarketRepository implements MarketRepository {\n  async findAll(filters?: MarketFilters): Promise<Market[]> {\n    let query = supabase.from('markets').select('*')\n\n    if (filters?.status) {\n      query = query.eq('status', filters.status)\n    }\n\n    if (filters?.limit) {\n      query = query.limit(filters.limit)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw new Error(error.message)\n    return data\n  }\n\n  // Other methods...\n}\n```",
      "zh-Hans": "```typescript\n// Abstract data access logic\ninterface MarketRepository {\n  findAll(filters?: MarketFilters): Promise<Market[]>\n  findById(id: string): Promise<Market | null>\n  create(data: CreateMarketDto): Promise<Market>\n  update(id: string, data: UpdateMarketDto): Promise<Market>\n  delete(id: string): Promise<void>\n}\n\nclass SupabaseMarketRepository implements MarketRepository {\n  async findAll(filters?: MarketFilters): Promise<Market[]> {\n    let query = supabase.from('markets').select('*')\n\n    if (filters?.status) {\n      query = query.eq('status', filters.status)\n    }\n\n    if (filters?.limit) {\n      query = query.limit(filters.limit)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw new Error(error.message)\n    return data\n  }\n\n  // Other methods...\n}\n```"
    },
    {
      "en-US": "### Service Layer Pattern",
      "zh-Hans": "### 服务层模式"
    },
    {
      "en-US": "```typescript\n// Business logic separated from data access\nclass MarketService {\n  constructor(private marketRepo: MarketRepository) {}\n\n  async searchMarkets(query: string, limit: number = 10): Promise<Market[]> {\n    // Business logic\n    const embedding = await generateEmbedding(query)\n    const results = await this.vectorSearch(embedding, limit)\n\n    // Fetch full data\n    const markets = await this.marketRepo.findByIds(results.map(r => r.id))\n\n    // Sort by similarity\n    return markets.sort((a, b) => {\n      const scoreA = results.find(r => r.id === a.id)?.score || 0\n      const scoreB = results.find(r => r.id === b.id)?.score || 0\n      return scoreA - scoreB\n    })\n  }\n\n  private async vectorSearch(embedding: number[], limit: number) {\n    // Vector search implementation\n  }\n}\n```",
      "zh-Hans": "```typescript\n// Business logic separated from data access\nclass MarketService {\n  constructor(private marketRepo: MarketRepository) {}\n\n  async searchMarkets(query: string, limit: number = 10): Promise<Market[]> {\n    // Business logic\n    const embedding = await generateEmbedding(query)\n    const results = await this.vectorSearch(embedding, limit)\n\n    // Fetch full data\n    const markets = await this.marketRepo.findByIds(results.map(r => r.id))\n\n    // Sort by similarity\n    return markets.sort((a, b) => {\n      const scoreA = results.find(r => r.id === a.id)?.score || 0\n      const scoreB = results.find(r => r.id === b.id)?.score || 0\n      return scoreA - scoreB\n    })\n  }\n\n  private async vectorSearch(embedding: number[], limit: number) {\n    // Vector search implementation\n  }\n}\n```"
    },
    {
      "en-US": "### Middleware Pattern",
      "zh-Hans": "### 中间件模式"
    },
    {
      "en-US": "```typescript\n// Request/response processing pipeline\nexport function withAuth(handler: NextApiHandler): NextApiHandler {\n  return async (req, res) => {\n    const token = req.headers.authorization?.replace('Bearer ', '')\n\n    if (!token) {\n      return res.status(401).json({ error: 'Unauthorized' })\n    }\n\n    try {\n      const user = await verifyToken(token)\n      req.user = user\n      return handler(req, res)\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' })\n    }\n  }\n}\n\n// Usage\nexport default withAuth(async (req, res) => {\n  // Handler has access to req.user\n})\n```",
      "zh-Hans": "```typescript\n// Request/response processing pipeline\nexport function withAuth(handler: NextApiHandler): NextApiHandler {\n  return async (req, res) => {\n    const token = req.headers.authorization?.replace('Bearer ', '')\n\n    if (!token) {\n      return res.status(401).json({ error: 'Unauthorized' })\n    }\n\n    try {\n      const user = await verifyToken(token)\n      req.user = user\n      return handler(req, res)\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' })\n    }\n  }\n}\n\n// Usage\nexport default withAuth(async (req, res) => {\n  // Handler has access to req.user\n})\n```"
    },
    {
      "en-US": "## Database Patterns",
      "zh-Hans": "## 数据库模式"
    },
    {
      "en-US": "### Query Optimization",
      "zh-Hans": "### 查询优化"
    },
    {
      "en-US": "```typescript\n// ✅ GOOD: Select only needed columns\nconst { data } = await supabase\n  .from('markets')\n  .select('id, name, status, volume')\n  .eq('status', 'active')\n  .order('volume', { ascending: false })\n  .limit(10)\n\n// ❌ BAD: Select everything\nconst { data } = await supabase\n  .from('markets')\n  .select('*')\n```",
      "zh-Hans": "```typescript\n// ✅ GOOD: Select only needed columns\nconst { data } = await supabase\n  .from('markets')\n  .select('id, name, status, volume')\n  .eq('status', 'active')\n  .order('volume', { ascending: false })\n  .limit(10)\n\n// ❌ BAD: Select everything\nconst { data } = await supabase\n  .from('markets')\n  .select('*')\n```"
    },
    {
      "en-US": "### N+1 Query Prevention",
      "zh-Hans": "### N+1 查询预防"
    },
    {
      "en-US": "```typescript\n// ❌ BAD: N+1 query problem\nconst markets = await getMarkets()\nfor (const market of markets) {\n  market.creator = await getUser(market.creator_id)  // N queries\n}\n\n// ✅ GOOD: Batch fetch\nconst markets = await getMarkets()\nconst creatorIds = markets.map(m => m.creator_id)\nconst creators = await getUsers(creatorIds)  // 1 query\nconst creatorMap = new Map(creators.map(c => [c.id, c]))\n\nmarkets.forEach(market => {\n  market.creator = creatorMap.get(market.creator_id)\n})\n```",
      "zh-Hans": "```typescript\n// ❌ BAD: N+1 query problem\nconst markets = await getMarkets()\nfor (const market of markets) {\n  market.creator = await getUser(market.creator_id)  // N queries\n}\n\n// ✅ GOOD: Batch fetch\nconst markets = await getMarkets()\nconst creatorIds = markets.map(m => m.creator_id)\nconst creators = await getUsers(creatorIds)  // 1 query\nconst creatorMap = new Map(creators.map(c => [c.id, c]))\n\nmarkets.forEach(market => {\n  market.creator = creatorMap.get(market.creator_id)\n})\n```"
    },
    {
      "en-US": "### Transaction Pattern",
      "zh-Hans": "### 事务模式"
    },
    {
      "en-US": "```typescript\nasync function createMarketWithPosition(\n  marketData: CreateMarketDto,\n  positionData: CreatePositionDto\n) {\n  // Use Supabase transaction\n  const { data, error } = await supabase.rpc('create_market_with_position', {\n    market_data: marketData,\n    position_data: positionData\n  })\n\n  if (error) throw new Error('Transaction failed')\n  return data\n}\n\n// SQL function in Supabase\nCREATE OR REPLACE FUNCTION create_market_with_position(\n  market_data jsonb,\n  position_data jsonb\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  -- Start transaction automatically\n  INSERT INTO markets VALUES (market_data);\n  INSERT INTO positions VALUES (position_data);\n  RETURN jsonb_build_object('success', true);\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Rollback happens automatically\n    RETURN jsonb_build_object('success', false, 'error', SQLERRM);\nEND;\n$$;\n```",
      "zh-Hans": "```typescript\nasync function createMarketWithPosition(\n  marketData: CreateMarketDto,\n  positionData: CreatePositionDto\n) {\n  // Use Supabase transaction\n  const { data, error } = await supabase.rpc('create_market_with_position', {\n    market_data: marketData,\n    position_data: positionData\n  })\n\n  if (error) throw new Error('Transaction failed')\n  return data\n}\n\n// SQL function in Supabase\nCREATE OR REPLACE FUNCTION create_market_with_position(\n  market_data jsonb,\n  position_data jsonb\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nAS $\nBEGIN\n  -- Start transaction automatically\n  INSERT INTO markets VALUES (market_data);\n  INSERT INTO positions VALUES (position_data);\n  RETURN jsonb_build_object('success', true);\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Rollback happens automatically\n    RETURN jsonb_build_object('success', false, 'error', SQLERRM);\nEND;\n$;\n```"
    },
    {
      "en-US": "## Caching Strategies",
      "zh-Hans": "## 缓存策略"
    },
    {
      "en-US": "### Redis Caching Layer",
      "zh-Hans": "### Redis 缓存层"
    },
    {
      "en-US": "```typescript\nclass CachedMarketRepository implements MarketRepository {\n  constructor(\n    private baseRepo: MarketRepository,\n    private redis: RedisClient\n  ) {}\n\n  async findById(id: string): Promise<Market | null> {\n    // Check cache first\n    const cached = await this.redis.get(`market:${id}`)\n\n    if (cached) {\n      return JSON.parse(cached)\n    }\n\n    // Cache miss - fetch from database\n    const market = await this.baseRepo.findById(id)\n\n    if (market) {\n      // Cache for 5 minutes\n      await this.redis.setex(`market:${id}`, 300, JSON.stringify(market))\n    }\n\n    return market\n  }\n\n  async invalidateCache(id: string): Promise<void> {\n    await this.redis.del(`market:${id}`)\n  }\n}\n```",
      "zh-Hans": "```typescript\nclass CachedMarketRepository implements MarketRepository {\n  constructor(\n    private baseRepo: MarketRepository,\n    private redis: RedisClient\n  ) {}\n\n  async findById(id: string): Promise<Market | null> {\n    // Check cache first\n    const cached = await this.redis.get(`market:${id}`)\n\n    if (cached) {\n      return JSON.parse(cached)\n    }\n\n    // Cache miss - fetch from database\n    const market = await this.baseRepo.findById(id)\n\n    if (market) {\n      // Cache for 5 minutes\n      await this.redis.setex(`market:${id}`, 300, JSON.stringify(market))\n    }\n\n    return market\n  }\n\n  async invalidateCache(id: string): Promise<void> {\n    await this.redis.del(`market:${id}`)\n  }\n}\n```"
    },
    {
      "en-US": "### Cache-Aside Pattern",
      "zh-Hans": "### 旁路缓存模式"
    },
    {
      "en-US": "```typescript\nasync function getMarketWithCache(id: string): Promise<Market> {\n  const cacheKey = `market:${id}`\n\n  // Try cache\n  const cached = await redis.get(cacheKey)\n  if (cached) return JSON.parse(cached)\n\n  // Cache miss - fetch from DB\n  const market = await db.markets.findUnique({ where: { id } })\n\n  if (!market) throw new Error('Market not found')\n\n  // Update cache\n  await redis.setex(cacheKey, 300, JSON.stringify(market))\n\n  return market\n}\n```",
      "zh-Hans": "```typescript\nasync function getMarketWithCache(id: string): Promise<Market> {\n  const cacheKey = `market:${id}`\n\n  // Try cache\n  const cached = await redis.get(cacheKey)\n  if (cached) return JSON.parse(cached)\n\n  // Cache miss - fetch from DB\n  const market = await db.markets.findUnique({ where: { id } })\n\n  if (!market) throw new Error('Market not found')\n\n  // Update cache\n  await redis.setex(cacheKey, 300, JSON.stringify(market))\n\n  return market\n}\n```"
    },
    {
      "en-US": "## Error Handling Patterns",
      "zh-Hans": "## 错误处理模式"
    },
    {
      "en-US": "### Centralized Error Handler",
      "zh-Hans": "### 集中式错误处理程序"
    },
    {
      "en-US": "```typescript\nclass ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public isOperational = true\n  ) {\n    super(message)\n    Object.setPrototypeOf(this, ApiError.prototype)\n  }\n}\n\nexport function errorHandler(error: unknown, req: Request): Response {\n  if (error instanceof ApiError) {\n    return NextResponse.json({\n      success: false,\n      error: error.message\n    }, { status: error.statusCode })\n  }\n\n  if (error instanceof z.ZodError) {\n    return NextResponse.json({\n      success: false,\n      error: 'Validation failed',\n      details: error.errors\n    }, { status: 400 })\n  }\n\n  // Log unexpected errors\n  console.error('Unexpected error:', error)\n\n  return NextResponse.json({\n    success: false,\n    error: 'Internal server error'\n  }, { status: 500 })\n}\n\n// Usage\nexport async function GET(request: Request) {\n  try {\n    const data = await fetchData()\n    return NextResponse.json({ success: true, data })\n  } catch (error) {\n    return errorHandler(error, request)\n  }\n}\n```",
      "zh-Hans": "```typescript\nclass ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public isOperational = true\n  ) {\n    super(message)\n    Object.setPrototypeOf(this, ApiError.prototype)\n  }\n}\n\nexport function errorHandler(error: unknown, req: Request): Response {\n  if (error instanceof ApiError) {\n    return NextResponse.json({\n      success: false,\n      error: error.message\n    }, { status: error.statusCode })\n  }\n\n  if (error instanceof z.ZodError) {\n    return NextResponse.json({\n      success: false,\n      error: 'Validation failed',\n      details: error.errors\n    }, { status: 400 })\n  }\n\n  // Log unexpected errors\n  console.error('Unexpected error:', error)\n\n  return NextResponse.json({\n    success: false,\n    error: 'Internal server error'\n  }, { status: 500 })\n}\n\n// Usage\nexport async function GET(request: Request) {\n  try {\n    const data = await fetchData()\n    return NextResponse.json({ success: true, data })\n  } catch (error) {\n    return errorHandler(error, request)\n  }\n}\n```"
    },
    {
      "en-US": "### Retry with Exponential Backoff",
      "zh-Hans": "### 指数退避重试"
    },
    {
      "en-US": "```typescript\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries = 3\n): Promise<T> {\n  let lastError: Error\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error as Error\n\n      if (i < maxRetries - 1) {\n        // Exponential backoff: 1s, 2s, 4s\n        const delay = Math.pow(2, i) * 1000\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n  }\n\n  throw lastError!\n}\n\n// Usage\nconst data = await fetchWithRetry(() => fetchFromAPI())\n```",
      "zh-Hans": "```typescript\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries = 3\n): Promise<T> {\n  let lastError: Error\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error as Error\n\n      if (i < maxRetries - 1) {\n        // Exponential backoff: 1s, 2s, 4s\n        const delay = Math.pow(2, i) * 1000\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n  }\n\n  throw lastError!\n}\n\n// Usage\nconst data = await fetchWithRetry(() => fetchFromAPI())\n```"
    },
    {
      "en-US": "## Authentication & Authorization",
      "zh-Hans": "## 认证与授权"
    },
    {
      "en-US": "### JWT Token Validation",
      "zh-Hans": "### JWT 令牌验证"
    },
    {
      "en-US": "```typescript\nimport jwt from 'jsonwebtoken'\n\ninterface JWTPayload {\n  userId: string\n  email: string\n  role: 'admin' | 'user'\n}\n\nexport function verifyToken(token: string): JWTPayload {\n  try {\n    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload\n    return payload\n  } catch (error) {\n    throw new ApiError(401, 'Invalid token')\n  }\n}\n\nexport async function requireAuth(request: Request) {\n  const token = request.headers.get('authorization')?.replace('Bearer ', '')\n\n  if (!token) {\n    throw new ApiError(401, 'Missing authorization token')\n  }\n\n  return verifyToken(token)\n}\n\n// Usage in API route\nexport async function GET(request: Request) {\n  const user = await requireAuth(request)\n\n  const data = await getDataForUser(user.userId)\n\n  return NextResponse.json({ success: true, data })\n}\n```",
      "zh-Hans": "```typescript\nimport jwt from 'jsonwebtoken'\n\ninterface JWTPayload {\n  userId: string\n  email: string\n  role: 'admin' | 'user'\n}\n\nexport function verifyToken(token: string): JWTPayload {\n  try {\n    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload\n    return payload\n  } catch (error) {\n    throw new ApiError(401, 'Invalid token')\n  }\n}\n\nexport async function requireAuth(request: Request) {\n  const token = request.headers.get('authorization')?.replace('Bearer ', '')\n\n  if (!token) {\n    throw new ApiError(401, 'Missing authorization token')\n  }\n\n  return verifyToken(token)\n}\n\n// Usage in API route\nexport async function GET(request: Request) {\n  const user = await requireAuth(request)\n\n  const data = await getDataForUser(user.userId)\n\n  return NextResponse.json({ success: true, data })\n}\n```"
    },
    {
      "en-US": "### Role-Based Access Control",
      "zh-Hans": "### 基于角色的访问控制"
    },
    {
      "en-US": "```typescript\ntype Permission = 'read' | 'write' | 'delete' | 'admin'\n\ninterface User {\n  id: string\n  role: 'admin' | 'moderator' | 'user'\n}\n\nconst rolePermissions: Record<User['role'], Permission[]> = {\n  admin: ['read', 'write', 'delete', 'admin'],\n  moderator: ['read', 'write', 'delete'],\n  user: ['read', 'write']\n}\n\nexport function hasPermission(user: User, permission: Permission): boolean {\n  return rolePermissions[user.role].includes(permission)\n}\n\nexport function requirePermission(permission: Permission) {\n  return (handler: (request: Request, user: User) => Promise<Response>) => {\n    return async (request: Request) => {\n      const user = await requireAuth(request)\n\n      if (!hasPermission(user, permission)) {\n        throw new ApiError(403, 'Insufficient permissions')\n      }\n\n      return handler(request, user)\n    }\n  }\n}\n\n// Usage - HOF wraps the handler\nexport const DELETE = requirePermission('delete')(\n  async (request: Request, user: User) => {\n    // Handler receives authenticated user with verified permission\n    return new Response('Deleted', { status: 200 })\n  }\n)\n```",
      "zh-Hans": "```typescript\ntype Permission = 'read' | 'write' | 'delete' | 'admin'\n\ninterface User {\n  id: string\n  role: 'admin' | 'moderator' | 'user'\n}\n\nconst rolePermissions: Record<User['role'], Permission[]> = {\n  admin: ['read', 'write', 'delete', 'admin'],\n  moderator: ['read', 'write', 'delete'],\n  user: ['read', 'write']\n}\n\nexport function hasPermission(user: User, permission: Permission): boolean {\n  return rolePermissions[user.role].includes(permission)\n}\n\nexport function requirePermission(permission: Permission) {\n  return (handler: (request: Request, user: User) => Promise<Response>) => {\n    return async (request: Request) => {\n      const user = await requireAuth(request)\n\n      if (!hasPermission(user, permission)) {\n        throw new ApiError(403, 'Insufficient permissions')\n      }\n\n      return handler(request, user)\n    }\n  }\n}\n\n// Usage - HOF wraps the handler\nexport const DELETE = requirePermission('delete')(\n  async (request: Request, user: User) => {\n    // Handler receives authenticated user with verified permission\n    return new Response('Deleted', { status: 200 })\n  }\n)\n```"
    },
    {
      "en-US": "## Rate Limiting",
      "zh-Hans": "## 速率限制"
    },
    {
      "en-US": "### Simple In-Memory Rate Limiter",
      "zh-Hans": "### 简单的内存速率限制器"
    },
    {
      "en-US": "```typescript\nclass RateLimiter {\n  private requests = new Map<string, number[]>()\n\n  async checkLimit(\n    identifier: string,\n    maxRequests: number,\n    windowMs: number\n  ): Promise<boolean> {\n    const now = Date.now()\n    const requests = this.requests.get(identifier) || []\n\n    // Remove old requests outside window\n    const recentRequests = requests.filter(time => now - time < windowMs)\n\n    if (recentRequests.length >= maxRequests) {\n      return false  // Rate limit exceeded\n    }\n\n    // Add current request\n    recentRequests.push(now)\n    this.requests.set(identifier, recentRequests)\n\n    return true\n  }\n}\n\nconst limiter = new RateLimiter()\n\nexport async function GET(request: Request) {\n  const ip = request.headers.get('x-forwarded-for') || 'unknown'\n\n  const allowed = await limiter.checkLimit(ip, 100, 60000)  // 100 req/min\n\n  if (!allowed) {\n    return NextResponse.json({\n      error: 'Rate limit exceeded'\n    }, { status: 429 })\n  }\n\n  // Continue with request\n}\n```",
      "zh-Hans": "```typescript\nclass RateLimiter {\n  private requests = new Map<string, number[]>()\n\n  async checkLimit(\n    identifier: string,\n    maxRequests: number,\n    windowMs: number\n  ): Promise<boolean> {\n    const now = Date.now()\n    const requests = this.requests.get(identifier) || []\n\n    // Remove old requests outside window\n    const recentRequests = requests.filter(time => now - time < windowMs)\n\n    if (recentRequests.length >= maxRequests) {\n      return false  // Rate limit exceeded\n    }\n\n    // Add current request\n    recentRequests.push(now)\n    this.requests.set(identifier, recentRequests)\n\n    return true\n  }\n}\n\nconst limiter = new RateLimiter()\n\nexport async function GET(request: Request) {\n  const ip = request.headers.get('x-forwarded-for') || 'unknown'\n\n  const allowed = await limiter.checkLimit(ip, 100, 60000)  // 100 req/min\n\n  if (!allowed) {\n    return NextResponse.json({\n      error: 'Rate limit exceeded'\n    }, { status: 429 })\n  }\n\n  // Continue with request\n}\n```"
    },
    {
      "en-US": "## Background Jobs & Queues",
      "zh-Hans": "## 后台作业与队列"
    },
    {
      "en-US": "### Simple Queue Pattern",
      "zh-Hans": "### 简单队列模式"
    },
    {
      "en-US": "```typescript\nclass JobQueue<T> {\n  private queue: T[] = []\n  private processing = false\n\n  async add(job: T): Promise<void> {\n    this.queue.push(job)\n\n    if (!this.processing) {\n      this.process()\n    }\n  }\n\n  private async process(): Promise<void> {\n    this.processing = true\n\n    while (this.queue.length > 0) {\n      const job = this.queue.shift()!\n\n      try {\n        await this.execute(job)\n      } catch (error) {\n        console.error('Job failed:', error)\n      }\n    }\n\n    this.processing = false\n  }\n\n  private async execute(job: T): Promise<void> {\n    // Job execution logic\n  }\n}\n\n// Usage for indexing markets\ninterface IndexJob {\n  marketId: string\n}\n\nconst indexQueue = new JobQueue<IndexJob>()\n\nexport async function POST(request: Request) {\n  const { marketId } = await request.json()\n\n  // Add to queue instead of blocking\n  await indexQueue.add({ marketId })\n\n  return NextResponse.json({ success: true, message: 'Job queued' })\n}\n```",
      "zh-Hans": "```typescript\nclass JobQueue<T> {\n  private queue: T[] = []\n  private processing = false\n\n  async add(job: T): Promise<void> {\n    this.queue.push(job)\n\n    if (!this.processing) {\n      this.process()\n    }\n  }\n\n  private async process(): Promise<void> {\n    this.processing = true\n\n    while (this.queue.length > 0) {\n      const job = this.queue.shift()!\n\n      try {\n        await this.execute(job)\n      } catch (error) {\n        console.error('Job failed:', error)\n      }\n    }\n\n    this.processing = false\n  }\n\n  private async execute(job: T): Promise<void> {\n    // Job execution logic\n  }\n}\n\n// Usage for indexing markets\ninterface IndexJob {\n  marketId: string\n}\n\nconst indexQueue = new JobQueue<IndexJob>()\n\nexport async function POST(request: Request) {\n  const { marketId } = await request.json()\n\n  // Add to queue instead of blocking\n  await indexQueue.add({ marketId })\n\n  return NextResponse.json({ success: true, message: 'Job queued' })\n}\n```"
    },
    {
      "en-US": "## Logging & Monitoring",
      "zh-Hans": "## 日志记录与监控"
    },
    {
      "en-US": "### Structured Logging",
      "zh-Hans": "### 结构化日志记录"
    },
    {
      "en-US": "```typescript\ninterface LogContext {\n  userId?: string\n  requestId?: string\n  method?: string\n  path?: string\n  [key: string]: unknown\n}\n\nclass Logger {\n  log(level: 'info' | 'warn' | 'error', message: string, context?: LogContext) {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      ...context\n    }\n\n    console.log(JSON.stringify(entry))\n  }\n\n  info(message: string, context?: LogContext) {\n    this.log('info', message, context)\n  }\n\n  warn(message: string, context?: LogContext) {\n    this.log('warn', message, context)\n  }\n\n  error(message: string, error: Error, context?: LogContext) {\n    this.log('error', message, {\n      ...context,\n      error: error.message,\n      stack: error.stack\n    })\n  }\n}\n\nconst logger = new Logger()\n\n// Usage\nexport async function GET(request: Request) {\n  const requestId = crypto.randomUUID()\n\n  logger.info('Fetching markets', {\n    requestId,\n    method: 'GET',\n    path: '/api/markets'\n  })\n\n  try {\n    const markets = await fetchMarkets()\n    return NextResponse.json({ success: true, data: markets })\n  } catch (error) {\n    logger.error('Failed to fetch markets', error as Error, { requestId })\n    return NextResponse.json({ error: 'Internal error' }, { status: 500 })\n  }\n}\n```",
      "zh-Hans": "```typescript\ninterface LogContext {\n  userId?: string\n  requestId?: string\n  method?: string\n  path?: string\n  [key: string]: unknown\n}\n\nclass Logger {\n  log(level: 'info' | 'warn' | 'error', message: string, context?: LogContext) {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      ...context\n    }\n\n    console.log(JSON.stringify(entry))\n  }\n\n  info(message: string, context?: LogContext) {\n    this.log('info', message, context)\n  }\n\n  warn(message: string, context?: LogContext) {\n    this.log('warn', message, context)\n  }\n\n  error(message: string, error: Error, context?: LogContext) {\n    this.log('error', message, {\n      ...context,\n      error: error.message,\n      stack: error.stack\n    })\n  }\n}\n\nconst logger = new Logger()\n\n// Usage\nexport async function GET(request: Request) {\n  const requestId = crypto.randomUUID()\n\n  logger.info('Fetching markets', {\n    requestId,\n    method: 'GET',\n    path: '/api/markets'\n  })\n\n  try {\n    const markets = await fetchMarkets()\n    return NextResponse.json({ success: true, data: markets })\n  } catch (error) {\n    logger.error('Failed to fetch markets', error as Error, { requestId })\n    return NextResponse.json({ error: 'Internal error' }, { status: 500 })\n  }\n}\n```"
    },
    {
      "en-US": "**Remember**: Backend patterns enable scalable, maintainable server-side applications. Choose patterns that fit your complexity level.",
      "zh-Hans": "**记住**：后端模式支持可扩展、可维护的服务器端应用程序。选择适合你复杂程度的模式。"
    }
  ]
}