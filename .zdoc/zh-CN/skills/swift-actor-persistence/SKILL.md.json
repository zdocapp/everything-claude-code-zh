{
  "sourceFile": "skills/swift-actor-persistence/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: swift-actor-persistence\ndescription: Thread-safe data persistence in Swift using actors — in-memory cache with file-backed storage, eliminating data races by design.\norigin: ECC\n---",
      "zh-Hans": "---\nname: swift-actor-persistence\ndescription: 在 Swift 中使用 actor 实现线程安全的数据持久化——基于内存缓存与文件支持的存储，通过设计消除数据竞争。\norigin: ECC\n---"
    },
    {
      "en-US": "# Swift Actors for Thread-Safe Persistence",
      "zh-Hans": "# 用于线程安全持久化的 Swift Actor"
    },
    {
      "en-US": "Patterns for building thread-safe data persistence layers using Swift actors. Combines in-memory caching with file-backed storage, leveraging the actor model to eliminate data races at compile time.",
      "zh-Hans": "使用 Swift actor 构建线程安全数据持久化层的模式。结合内存缓存与文件支持的存储，利用 actor 模型在编译时消除数据竞争。"
    },
    {
      "en-US": "## When to Activate",
      "zh-Hans": "## 何时激活"
    },
    {
      "en-US": "- Building a data persistence layer in Swift 5.5+\n- Need thread-safe access to shared mutable state\n- Want to eliminate manual synchronization (locks, DispatchQueues)\n- Building offline-first apps with local storage",
      "zh-Hans": "* 在 Swift 5.5+ 中构建数据持久化层\n* 需要对共享可变状态进行线程安全访问\n* 希望消除手动同步（锁、DispatchQueue）\n* 构建具有本地存储的离线优先应用"
    },
    {
      "en-US": "## Core Pattern",
      "zh-Hans": "## 核心模式"
    },
    {
      "en-US": "### Actor-Based Repository",
      "zh-Hans": "### 基于 Actor 的存储库"
    },
    {
      "en-US": "The actor model guarantees serialized access — no data races, enforced by the compiler.",
      "zh-Hans": "Actor 模型保证了序列化访问 —— 没有数据竞争，由编译器强制执行。"
    },
    {
      "en-US": "```swift\npublic actor LocalRepository<T: Codable & Identifiable> where T.ID == String {\n    private var cache: [String: T] = [:]\n    private let fileURL: URL\n\n    public init(directory: URL = .documentsDirectory, filename: String = \"data.json\") {\n        self.fileURL = directory.appendingPathComponent(filename)\n        // Synchronous load during init (actor isolation not yet active)\n        self.cache = Self.loadSynchronously(from: fileURL)\n    }\n\n    // MARK: - Public API\n\n    public func save(_ item: T) throws {\n        cache[item.id] = item\n        try persistToFile()\n    }\n\n    public func delete(_ id: String) throws {\n        cache[id] = nil\n        try persistToFile()\n    }\n\n    public func find(by id: String) -> T? {\n        cache[id]\n    }\n\n    public func loadAll() -> [T] {\n        Array(cache.values)\n    }\n\n    // MARK: - Private\n\n    private func persistToFile() throws {\n        let data = try JSONEncoder().encode(Array(cache.values))\n        try data.write(to: fileURL, options: .atomic)\n    }\n\n    private static func loadSynchronously(from url: URL) -> [String: T] {\n        guard let data = try? Data(contentsOf: url),\n              let items = try? JSONDecoder().decode([T].self, from: data) else {\n            return [:]\n        }\n        return Dictionary(uniqueKeysWithValues: items.map { ($0.id, $0) })\n    }\n}\n```",
      "zh-Hans": "```swift\npublic actor LocalRepository<T: Codable & Identifiable> where T.ID == String {\n    private var cache: [String: T] = [:]\n    private let fileURL: URL\n\n    public init(directory: URL = .documentsDirectory, filename: String = \"data.json\") {\n        self.fileURL = directory.appendingPathComponent(filename)\n        // Synchronous load during init (actor isolation not yet active)\n        self.cache = Self.loadSynchronously(from: fileURL)\n    }\n\n    // MARK: - Public API\n\n    public func save(_ item: T) throws {\n        cache[item.id] = item\n        try persistToFile()\n    }\n\n    public func delete(_ id: String) throws {\n        cache[id] = nil\n        try persistToFile()\n    }\n\n    public func find(by id: String) -> T? {\n        cache[id]\n    }\n\n    public func loadAll() -> [T] {\n        Array(cache.values)\n    }\n\n    // MARK: - Private\n\n    private func persistToFile() throws {\n        let data = try JSONEncoder().encode(Array(cache.values))\n        try data.write(to: fileURL, options: .atomic)\n    }\n\n    private static func loadSynchronously(from url: URL) -> [String: T] {\n        guard let data = try? Data(contentsOf: url),\n              let items = try? JSONDecoder().decode([T].self, from: data) else {\n            return [:]\n        }\n        return Dictionary(uniqueKeysWithValues: items.map { ($0.id, $0) })\n    }\n}\n```"
    },
    {
      "en-US": "### Usage",
      "zh-Hans": "### 用法"
    },
    {
      "en-US": "All calls are automatically async due to actor isolation:",
      "zh-Hans": "由于 actor 隔离，所有调用都会自动变为异步："
    },
    {
      "en-US": "```swift\nlet repository = LocalRepository<Question>()\n\n// Read — fast O(1) lookup from in-memory cache\nlet question = await repository.find(by: \"q-001\")\nlet allQuestions = await repository.loadAll()\n\n// Write — updates cache and persists to file atomically\ntry await repository.save(newQuestion)\ntry await repository.delete(\"q-001\")\n```",
      "zh-Hans": "```swift\nlet repository = LocalRepository<Question>()\n\n// Read — fast O(1) lookup from in-memory cache\nlet question = await repository.find(by: \"q-001\")\nlet allQuestions = await repository.loadAll()\n\n// Write — updates cache and persists to file atomically\ntry await repository.save(newQuestion)\ntry await repository.delete(\"q-001\")\n```"
    },
    {
      "en-US": "### Combining with @Observable ViewModel",
      "zh-Hans": "### 与 @Observable ViewModel 结合使用"
    },
    {
      "en-US": "```swift\n@Observable\nfinal class QuestionListViewModel {\n    private(set) var questions: [Question] = []\n    private let repository: LocalRepository<Question>\n\n    init(repository: LocalRepository<Question> = LocalRepository()) {\n        self.repository = repository\n    }\n\n    func load() async {\n        questions = await repository.loadAll()\n    }\n\n    func add(_ question: Question) async throws {\n        try await repository.save(question)\n        questions = await repository.loadAll()\n    }\n}\n```",
      "zh-Hans": "```swift\n@Observable\nfinal class QuestionListViewModel {\n    private(set) var questions: [Question] = []\n    private let repository: LocalRepository<Question>\n\n    init(repository: LocalRepository<Question> = LocalRepository()) {\n        self.repository = repository\n    }\n\n    func load() async {\n        questions = await repository.loadAll()\n    }\n\n    func add(_ question: Question) async throws {\n        try await repository.save(question)\n        questions = await repository.loadAll()\n    }\n}\n```"
    },
    {
      "en-US": "## Key Design Decisions",
      "zh-Hans": "## 关键设计决策"
    },
    {
      "en-US": "| Decision | Rationale |\n|----------|-----------|\n| Actor (not class + lock) | Compiler-enforced thread safety, no manual synchronization |\n| In-memory cache + file persistence | Fast reads from cache, durable writes to disk |\n| Synchronous init loading | Avoids async initialization complexity |\n| Dictionary keyed by ID | O(1) lookups by identifier |\n| Generic over `Codable & Identifiable` | Reusable across any model type |\n| Atomic file writes (`.atomic`) | Prevents partial writes on crash |",
      "zh-Hans": "| 决策 | 理由 |\n|----------|-----------|\n| Actor（而非类 + 锁） | 编译器强制执行的线程安全性，无需手动同步 |\n| 内存缓存 + 文件持久化 | 从缓存中快速读取，持久化写入磁盘 |\n| 同步初始化加载 | 避免异步初始化的复杂性 |\n| 按 ID 键控的字典 | 按标识符进行 O(1) 查找 |\n| 泛型化 `Codable & Identifiable` | 可在任何模型类型中重复使用 |\n| 原子文件写入 (`.atomic`) | 防止崩溃时部分写入 |"
    },
    {
      "en-US": "## Best Practices",
      "zh-Hans": "## 最佳实践"
    },
    {
      "en-US": "- **Use `Sendable` types** for all data crossing actor boundaries\n- **Keep the actor's public API minimal** — only expose domain operations, not persistence details\n- **Use `.atomic` writes** to prevent data corruption if the app crashes mid-write\n- **Load synchronously in `init`** — async initializers add complexity with minimal benefit for local files\n- **Combine with `@Observable`** ViewModels for reactive UI updates",
      "zh-Hans": "* **对所有跨越 actor 边界的数据使用 `Sendable` 类型**\n* **保持 actor 的公共 API 最小化** —— 仅暴露领域操作，而非持久化细节\n* **使用 `.atomic` 写入** 以防止应用在写入过程中崩溃导致数据损坏\n* **在 `init` 中同步加载** —— 异步初始化器会增加复杂性，而对本地文件的益处微乎其微\n* **与 `@Observable` ViewModel 结合使用** 以实现响应式 UI 更新"
    },
    {
      "en-US": "## Anti-Patterns to Avoid",
      "zh-Hans": "## 应避免的反模式"
    },
    {
      "en-US": "- Using `DispatchQueue` or `NSLock` instead of actors for new Swift concurrency code\n- Exposing the internal cache dictionary to external callers\n- Making the file URL configurable without validation\n- Forgetting that all actor method calls are `await` — callers must handle async context\n- Using `nonisolated` to bypass actor isolation (defeats the purpose)",
      "zh-Hans": "* 在 Swift 并发新代码中使用 `DispatchQueue` 或 `NSLock` 而非 actor\n* 将内部缓存字典暴露给外部调用者\n* 在不进行验证的情况下使文件 URL 可配置\n* 忘记所有 actor 方法调用都是 `await` —— 调用者必须处理异步上下文\n* 使用 `nonisolated` 来绕过 actor 隔离（违背了初衷）"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "- Local data storage in iOS/macOS apps (user data, settings, cached content)\n- Offline-first architectures that sync to a server later\n- Any shared mutable state that multiple parts of the app access concurrently\n- Replacing legacy `DispatchQueue`-based thread safety with modern Swift concurrency",
      "zh-Hans": "* iOS/macOS 应用中的本地数据存储（用户数据、设置、缓存内容）\n* 稍后同步到服务器的离线优先架构\n* 应用中多个部分并发访问的任何共享可变状态\n* 用现代 Swift 并发性替换基于 `DispatchQueue` 的旧式线程安全机制"
    }
  ]
}