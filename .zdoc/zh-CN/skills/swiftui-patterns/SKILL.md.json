{
  "sourceFile": "skills/swiftui-patterns/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: swiftui-patterns\ndescription: SwiftUI architecture patterns, state management with @Observable, view composition, navigation, performance optimization, and modern iOS/macOS UI best practices.\n---",
      "zh-Hans": "---\nname: swiftui-patterns\ndescription: SwiftUI 架构模式，使用 @Observable 进行状态管理，视图组合，导航，性能优化，以及现代 iOS/macOS UI 最佳实践。\n---"
    },
    {
      "en-US": "# SwiftUI Patterns",
      "zh-Hans": "# SwiftUI 模式"
    },
    {
      "en-US": "Modern SwiftUI patterns for building declarative, performant user interfaces on Apple platforms. Covers the Observation framework, view composition, type-safe navigation, and performance optimization.",
      "zh-Hans": "适用于 Apple 平台的现代 SwiftUI 模式，用于构建声明式、高性能的用户界面。涵盖 Observation 框架、视图组合、类型安全导航和性能优化。"
    },
    {
      "en-US": "## When to Activate",
      "zh-Hans": "## 何时激活"
    },
    {
      "en-US": "- Building SwiftUI views and managing state (`@State`, `@Observable`, `@Binding`)\n- Designing navigation flows with `NavigationStack`\n- Structuring view models and data flow\n- Optimizing rendering performance for lists and complex layouts\n- Working with environment values and dependency injection in SwiftUI",
      "zh-Hans": "* 构建 SwiftUI 视图和管理状态时（`@State`、`@Observable`、`@Binding`）\n* 使用 `NavigationStack` 设计导航流程时\n* 构建视图模型和数据流时\n* 优化列表和复杂布局的渲染性能时\n* 在 SwiftUI 中使用环境值和依赖注入时"
    },
    {
      "en-US": "## State Management",
      "zh-Hans": "## 状态管理"
    },
    {
      "en-US": "### Property Wrapper Selection",
      "zh-Hans": "### 属性包装器选择"
    },
    {
      "en-US": "Choose the simplest wrapper that fits:",
      "zh-Hans": "选择最适合的最简单包装器："
    },
    {
      "en-US": "| Wrapper | Use Case |\n|---------|----------|\n| `@State` | View-local value types (toggles, form fields, sheet presentation) |\n| `@Binding` | Two-way reference to parent's `@State` |\n| `@Observable` class + `@State` | Owned model with multiple properties |\n| `@Observable` class (no wrapper) | Read-only reference passed from parent |\n| `@Bindable` | Two-way binding to an `@Observable` property |\n| `@Environment` | Shared dependencies injected via `.environment()` |",
      "zh-Hans": "| 包装器 | 使用场景 |\n|---------|----------|\n| `@State` | 视图本地的值类型（开关、表单字段、Sheet 展示） |\n| `@Binding` | 指向父视图 `@State` 的双向引用 |\n| `@Observable` 类 + `@State` | 拥有多个属性的自有模型 |\n| `@Observable` 类（无包装器） | 从父视图传递的只读引用 |\n| `@Bindable` | 指向 `@Observable` 属性的双向绑定 |\n| `@Environment` | 通过 `.environment()` 注入的共享依赖项 |"
    },
    {
      "en-US": "### @Observable ViewModel",
      "zh-Hans": "### @Observable ViewModel"
    },
    {
      "en-US": "Use `@Observable` (not `ObservableObject`) — it tracks property-level changes so SwiftUI only re-renders views that read the changed property:",
      "zh-Hans": "使用 `@Observable`（而非 `ObservableObject`）—— 它跟踪属性级别的变更，因此 SwiftUI 只会重新渲染读取了已变更属性的视图："
    },
    {
      "en-US": "```swift\n@Observable\nfinal class ItemListViewModel {\n    private(set) var items: [Item] = []\n    private(set) var isLoading = false\n    var searchText = \"\"\n\n    private let repository: any ItemRepository\n\n    init(repository: any ItemRepository = DefaultItemRepository()) {\n        self.repository = repository\n    }\n\n    func load() async {\n        isLoading = true\n        defer { isLoading = false }\n        items = (try? await repository.fetchAll()) ?? []\n    }\n}\n```",
      "zh-Hans": "```swift\n@Observable\nfinal class ItemListViewModel {\n    private(set) var items: [Item] = []\n    private(set) var isLoading = false\n    var searchText = \"\"\n\n    private let repository: any ItemRepository\n\n    init(repository: any ItemRepository = DefaultItemRepository()) {\n        self.repository = repository\n    }\n\n    func load() async {\n        isLoading = true\n        defer { isLoading = false }\n        items = (try? await repository.fetchAll()) ?? []\n    }\n}\n```"
    },
    {
      "en-US": "### View Consuming the ViewModel",
      "zh-Hans": "### 消费 ViewModel 的视图"
    },
    {
      "en-US": "```swift\nstruct ItemListView: View {\n    @State private var viewModel: ItemListViewModel\n\n    init(viewModel: ItemListViewModel = ItemListViewModel()) {\n        _viewModel = State(initialValue: viewModel)\n    }\n\n    var body: some View {\n        List(viewModel.items) { item in\n            ItemRow(item: item)\n        }\n        .searchable(text: $viewModel.searchText)\n        .overlay { if viewModel.isLoading { ProgressView() } }\n        .task { await viewModel.load() }\n    }\n}\n```",
      "zh-Hans": "```swift\nstruct ItemListView: View {\n    @State private var viewModel: ItemListViewModel\n\n    init(viewModel: ItemListViewModel = ItemListViewModel()) {\n        _viewModel = State(initialValue: viewModel)\n    }\n\n    var body: some View {\n        List(viewModel.items) { item in\n            ItemRow(item: item)\n        }\n        .searchable(text: $viewModel.searchText)\n        .overlay { if viewModel.isLoading { ProgressView() } }\n        .task { await viewModel.load() }\n    }\n}\n```"
    },
    {
      "en-US": "### Environment Injection",
      "zh-Hans": "### 环境注入"
    },
    {
      "en-US": "Replace `@EnvironmentObject` with `@Environment`:",
      "zh-Hans": "用 `@Environment` 替换 `@EnvironmentObject`："
    },
    {
      "en-US": "```swift\n// Inject\nContentView()\n    .environment(authManager)\n\n// Consume\nstruct ProfileView: View {\n    @Environment(AuthManager.self) private var auth\n\n    var body: some View {\n        Text(auth.currentUser?.name ?? \"Guest\")\n    }\n}\n```",
      "zh-Hans": "```swift\n// Inject\nContentView()\n    .environment(authManager)\n\n// Consume\nstruct ProfileView: View {\n    @Environment(AuthManager.self) private var auth\n\n    var body: some View {\n        Text(auth.currentUser?.name ?? \"Guest\")\n    }\n}\n```"
    },
    {
      "en-US": "## View Composition",
      "zh-Hans": "## 视图组合"
    },
    {
      "en-US": "### Extract Subviews to Limit Invalidation",
      "zh-Hans": "### 提取子视图以限制失效"
    },
    {
      "en-US": "Break views into small, focused structs. When state changes, only the subview reading that state re-renders:",
      "zh-Hans": "将视图拆分为小型、专注的结构体。当状态变更时，只有读取该状态的子视图会重新渲染："
    },
    {
      "en-US": "```swift\nstruct OrderView: View {\n    @State private var viewModel = OrderViewModel()\n\n    var body: some View {\n        VStack {\n            OrderHeader(title: viewModel.title)\n            OrderItemList(items: viewModel.items)\n            OrderTotal(total: viewModel.total)\n        }\n    }\n}\n```",
      "zh-Hans": "```swift\nstruct OrderView: View {\n    @State private var viewModel = OrderViewModel()\n\n    var body: some View {\n        VStack {\n            OrderHeader(title: viewModel.title)\n            OrderItemList(items: viewModel.items)\n            OrderTotal(total: viewModel.total)\n        }\n    }\n}\n```"
    },
    {
      "en-US": "### ViewModifier for Reusable Styling",
      "zh-Hans": "### 用于可复用样式的 ViewModifier"
    },
    {
      "en-US": "```swift\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(.regularMaterial)\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        modifier(CardModifier())\n    }\n}\n```",
      "zh-Hans": "```swift\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(.regularMaterial)\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        modifier(CardModifier())\n    }\n}\n```"
    },
    {
      "en-US": "## Navigation",
      "zh-Hans": "## 导航"
    },
    {
      "en-US": "### Type-Safe NavigationStack",
      "zh-Hans": "### 类型安全的 NavigationStack"
    },
    {
      "en-US": "Use `NavigationStack` with `NavigationPath` for programmatic, type-safe routing:",
      "zh-Hans": "使用 `NavigationStack` 与 `NavigationPath` 来实现程序化、类型安全的路由："
    },
    {
      "en-US": "```swift\n@Observable\nfinal class Router {\n    var path = NavigationPath()\n\n    func navigate(to destination: Destination) {\n        path.append(destination)\n    }\n\n    func popToRoot() {\n        path = NavigationPath()\n    }\n}\n\nenum Destination: Hashable {\n    case detail(Item.ID)\n    case settings\n    case profile(User.ID)\n}\n\nstruct RootView: View {\n    @State private var router = Router()\n\n    var body: some View {\n        NavigationStack(path: $router.path) {\n            HomeView()\n                .navigationDestination(for: Destination.self) { dest in\n                    switch dest {\n                    case .detail(let id): ItemDetailView(itemID: id)\n                    case .settings: SettingsView()\n                    case .profile(let id): ProfileView(userID: id)\n                    }\n                }\n        }\n        .environment(router)\n    }\n}\n```",
      "zh-Hans": "```swift\n@Observable\nfinal class Router {\n    var path = NavigationPath()\n\n    func navigate(to destination: Destination) {\n        path.append(destination)\n    }\n\n    func popToRoot() {\n        path = NavigationPath()\n    }\n}\n\nenum Destination: Hashable {\n    case detail(Item.ID)\n    case settings\n    case profile(User.ID)\n}\n\nstruct RootView: View {\n    @State private var router = Router()\n\n    var body: some View {\n        NavigationStack(path: $router.path) {\n            HomeView()\n                .navigationDestination(for: Destination.self) { dest in\n                    switch dest {\n                    case .detail(let id): ItemDetailView(itemID: id)\n                    case .settings: SettingsView()\n                    case .profile(let id): ProfileView(userID: id)\n                    }\n                }\n        }\n        .environment(router)\n    }\n}\n```"
    },
    {
      "en-US": "## Performance",
      "zh-Hans": "## 性能"
    },
    {
      "en-US": "### Use Lazy Containers for Large Collections",
      "zh-Hans": "### 为大型集合使用惰性容器"
    },
    {
      "en-US": "`LazyVStack` and `LazyHStack` create views only when visible:",
      "zh-Hans": "`LazyVStack` 和 `LazyHStack` 仅在视图可见时才创建它们："
    },
    {
      "en-US": "```swift\nScrollView {\n    LazyVStack(spacing: 8) {\n        ForEach(items) { item in\n            ItemRow(item: item)\n        }\n    }\n}\n```",
      "zh-Hans": "```swift\nScrollView {\n    LazyVStack(spacing: 8) {\n        ForEach(items) { item in\n            ItemRow(item: item)\n        }\n    }\n}\n```"
    },
    {
      "en-US": "### Stable Identifiers",
      "zh-Hans": "### 稳定的标识符"
    },
    {
      "en-US": "Always use stable, unique IDs in `ForEach` — avoid using array indices:",
      "zh-Hans": "在 `ForEach` 中始终使用稳定、唯一的 ID —— 避免使用数组索引："
    },
    {
      "en-US": "```swift\n// Use Identifiable conformance or explicit id\nForEach(items, id: \\.stableID) { item in\n    ItemRow(item: item)\n}\n```",
      "zh-Hans": "```swift\n// Use Identifiable conformance or explicit id\nForEach(items, id: \\.stableID) { item in\n    ItemRow(item: item)\n}\n```"
    },
    {
      "en-US": "### Avoid Expensive Work in body",
      "zh-Hans": "### 避免在 body 中进行昂贵操作"
    },
    {
      "en-US": "- Never perform I/O, network calls, or heavy computation inside `body`\n- Use `.task {}` for async work — it cancels automatically when the view disappears\n- Use `.sensoryFeedback()` and `.geometryGroup()` sparingly in scroll views\n- Minimize `.shadow()`, `.blur()`, and `.mask()` in lists — they trigger offscreen rendering",
      "zh-Hans": "* 切勿在 `body` 内执行 I/O、网络调用或繁重计算\n* 使用 `.task {}` 处理异步工作 —— 当视图消失时它会自动取消\n* 在滚动视图中谨慎使用 `.sensoryFeedback()` 和 `.geometryGroup()`\n* 在列表中最小化使用 `.shadow()`、`.blur()` 和 `.mask()` —— 它们会触发屏幕外渲染"
    },
    {
      "en-US": "### Equatable Conformance",
      "zh-Hans": "### 遵循 Equatable"
    },
    {
      "en-US": "For views with expensive bodies, conform to `Equatable` to skip unnecessary re-renders:",
      "zh-Hans": "对于 body 计算昂贵的视图，遵循 `Equatable` 以跳过不必要的重新渲染："
    },
    {
      "en-US": "```swift\nstruct ExpensiveChartView: View, Equatable {\n    let dataPoints: [DataPoint] // DataPoint must conform to Equatable\n\n    static func == (lhs: Self, rhs: Self) -> Bool {\n        lhs.dataPoints == rhs.dataPoints\n    }\n\n    var body: some View {\n        // Complex chart rendering\n    }\n}\n```",
      "zh-Hans": "```swift\nstruct ExpensiveChartView: View, Equatable {\n    let dataPoints: [DataPoint] // DataPoint must conform to Equatable\n\n    static func == (lhs: Self, rhs: Self) -> Bool {\n        lhs.dataPoints == rhs.dataPoints\n    }\n\n    var body: some View {\n        // Complex chart rendering\n    }\n}\n```"
    },
    {
      "en-US": "## Previews",
      "zh-Hans": "## 预览"
    },
    {
      "en-US": "Use `#Preview` macro with inline mock data for fast iteration:",
      "zh-Hans": "使用 `#Preview` 宏配合内联模拟数据以进行快速迭代："
    },
    {
      "en-US": "```swift\n#Preview(\"Empty state\") {\n    ItemListView(viewModel: ItemListViewModel(repository: EmptyMockRepository()))\n}\n\n#Preview(\"Loaded\") {\n    ItemListView(viewModel: ItemListViewModel(repository: PopulatedMockRepository()))\n}\n```",
      "zh-Hans": "```swift\n#Preview(\"Empty state\") {\n    ItemListView(viewModel: ItemListViewModel(repository: EmptyMockRepository()))\n}\n\n#Preview(\"Loaded\") {\n    ItemListView(viewModel: ItemListViewModel(repository: PopulatedMockRepository()))\n}\n```"
    },
    {
      "en-US": "## Anti-Patterns to Avoid",
      "zh-Hans": "## 应避免的反模式"
    },
    {
      "en-US": "- Using `ObservableObject` / `@Published` / `@StateObject` / `@EnvironmentObject` in new code — migrate to `@Observable`\n- Putting async work directly in `body` or `init` — use `.task {}` or explicit load methods\n- Creating view models as `@State` inside child views that don't own the data — pass from parent instead\n- Using `AnyView` type erasure — prefer `@ViewBuilder` or `Group` for conditional views\n- Ignoring `Sendable` requirements when passing data to/from actors",
      "zh-Hans": "* 在新代码中使用 `ObservableObject` / `@Published` / `@StateObject` / `@EnvironmentObject` —— 迁移到 `@Observable`\n* 将异步工作直接放在 `body` 或 `init` 中 —— 使用 `.task {}` 或显式的加载方法\n* 在不拥有数据的子视图中将视图模型创建为 `@State` —— 改为从父视图传递\n* 使用 `AnyView` 类型擦除 —— 对于条件视图，优先选择 `@ViewBuilder` 或 `Group`\n* 在向 Actor 传递数据或从 Actor 接收数据时忽略 `Sendable` 要求"
    },
    {
      "en-US": "## References",
      "zh-Hans": "## 参考"
    },
    {
      "en-US": "See skill: `swift-actor-persistence` for actor-based persistence patterns.\nSee skill: `swift-protocol-di-testing` for protocol-based DI and testing with Swift Testing.",
      "zh-Hans": "查看技能：`swift-actor-persistence` 以了解基于 Actor 的持久化模式。\n查看技能：`swift-protocol-di-testing` 以了解基于协议的 DI 和使用 Swift Testing 进行测试。"
    }
  ]
}