{
  "sourceFile": "skills/golang-patterns/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: golang-patterns\ndescription: Idiomatic Go patterns, best practices, and conventions for building robust, efficient, and maintainable Go applications.\norigin: ECC\n---",
      "zh-Hans": "---\nname: golang-patterns\ndescription: 用于构建健壮、高效且可维护的Go应用程序的惯用Go模式、最佳实践和约定。\norigin: ECC\n---"
    },
    {
      "en-US": "# Go Development Patterns",
      "zh-Hans": "# Go 开发模式"
    },
    {
      "en-US": "Idiomatic Go patterns and best practices for building robust, efficient, and maintainable applications.",
      "zh-Hans": "用于构建健壮、高效和可维护应用程序的惯用 Go 模式与最佳实践。"
    },
    {
      "en-US": "## When to Activate",
      "zh-Hans": "## 何时激活"
    },
    {
      "en-US": "- Writing new Go code\n- Reviewing Go code\n- Refactoring existing Go code\n- Designing Go packages/modules",
      "zh-Hans": "* 编写新的 Go 代码时\n* 审查 Go 代码时\n* 重构现有 Go 代码时\n* 设计 Go 包/模块时"
    },
    {
      "en-US": "## Core Principles",
      "zh-Hans": "## 核心原则"
    },
    {
      "en-US": "### 1. Simplicity and Clarity",
      "zh-Hans": "### 1. 简洁与清晰"
    },
    {
      "en-US": "Go favors simplicity over cleverness. Code should be obvious and easy to read.",
      "zh-Hans": "Go 推崇简洁而非精巧。代码应该显而易见且易于阅读。"
    },
    {
      "en-US": "```go\n// Good: Clear and direct\nfunc GetUser(id string) (*User, error) {\n    user, err := db.FindUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"get user %s: %w\", id, err)\n    }\n    return user, nil\n}\n\n// Bad: Overly clever\nfunc GetUser(id string) (*User, error) {\n    return func() (*User, error) {\n        if u, e := db.FindUser(id); e == nil {\n            return u, nil\n        } else {\n            return nil, e\n        }\n    }()\n}\n```",
      "zh-Hans": "```go\n// Good: Clear and direct\nfunc GetUser(id string) (*User, error) {\n    user, err := db.FindUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"get user %s: %w\", id, err)\n    }\n    return user, nil\n}\n\n// Bad: Overly clever\nfunc GetUser(id string) (*User, error) {\n    return func() (*User, error) {\n        if u, e := db.FindUser(id); e == nil {\n            return u, nil\n        } else {\n            return nil, e\n        }\n    }()\n}\n```"
    },
    {
      "en-US": "### 2. Make the Zero Value Useful",
      "zh-Hans": "### 2. 让零值变得有用"
    },
    {
      "en-US": "Design types so their zero value is immediately usable without initialization.",
      "zh-Hans": "设计类型时，应使其零值无需初始化即可立即使用。"
    },
    {
      "en-US": "```go\n// Good: Zero value is useful\ntype Counter struct {\n    mu    sync.Mutex\n    count int // zero value is 0, ready to use\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    c.count++\n    c.mu.Unlock()\n}\n\n// Good: bytes.Buffer works with zero value\nvar buf bytes.Buffer\nbuf.WriteString(\"hello\")\n\n// Bad: Requires initialization\ntype BadCounter struct {\n    counts map[string]int // nil map will panic\n}\n```",
      "zh-Hans": "```go\n// Good: Zero value is useful\ntype Counter struct {\n    mu    sync.Mutex\n    count int // zero value is 0, ready to use\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    c.count++\n    c.mu.Unlock()\n}\n\n// Good: bytes.Buffer works with zero value\nvar buf bytes.Buffer\nbuf.WriteString(\"hello\")\n\n// Bad: Requires initialization\ntype BadCounter struct {\n    counts map[string]int // nil map will panic\n}\n```"
    },
    {
      "en-US": "### 3. Accept Interfaces, Return Structs",
      "zh-Hans": "### 3. 接受接口，返回结构体"
    },
    {
      "en-US": "Functions should accept interface parameters and return concrete types.",
      "zh-Hans": "函数应该接受接口参数并返回具体类型。"
    },
    {
      "en-US": "```go\n// Good: Accepts interface, returns concrete type\nfunc ProcessData(r io.Reader) (*Result, error) {\n    data, err := io.ReadAll(r)\n    if err != nil {\n        return nil, err\n    }\n    return &Result{Data: data}, nil\n}\n\n// Bad: Returns interface (hides implementation details unnecessarily)\nfunc ProcessData(r io.Reader) (io.Reader, error) {\n    // ...\n}\n```",
      "zh-Hans": "```go\n// Good: Accepts interface, returns concrete type\nfunc ProcessData(r io.Reader) (*Result, error) {\n    data, err := io.ReadAll(r)\n    if err != nil {\n        return nil, err\n    }\n    return &Result{Data: data}, nil\n}\n\n// Bad: Returns interface (hides implementation details unnecessarily)\nfunc ProcessData(r io.Reader) (io.Reader, error) {\n    // ...\n}\n```"
    },
    {
      "en-US": "## Error Handling Patterns",
      "zh-Hans": "## 错误处理模式"
    },
    {
      "en-US": "### Error Wrapping with Context",
      "zh-Hans": "### 带上下文的错误包装"
    },
    {
      "en-US": "```go\n// Good: Wrap errors with context\nfunc LoadConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"load config %s: %w\", path, err)\n    }\n\n    var cfg Config\n    if err := json.Unmarshal(data, &cfg); err != nil {\n        return nil, fmt.Errorf(\"parse config %s: %w\", path, err)\n    }\n\n    return &cfg, nil\n}\n```",
      "zh-Hans": "```go\n// Good: Wrap errors with context\nfunc LoadConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"load config %s: %w\", path, err)\n    }\n\n    var cfg Config\n    if err := json.Unmarshal(data, &cfg); err != nil {\n        return nil, fmt.Errorf(\"parse config %s: %w\", path, err)\n    }\n\n    return &cfg, nil\n}\n```"
    },
    {
      "en-US": "### Custom Error Types",
      "zh-Hans": "### 自定义错误类型"
    },
    {
      "en-US": "```go\n// Define domain-specific errors\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed on %s: %s\", e.Field, e.Message)\n}\n\n// Sentinel errors for common cases\nvar (\n    ErrNotFound     = errors.New(\"resource not found\")\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    ErrInvalidInput = errors.New(\"invalid input\")\n)\n```",
      "zh-Hans": "```go\n// Define domain-specific errors\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed on %s: %s\", e.Field, e.Message)\n}\n\n// Sentinel errors for common cases\nvar (\n    ErrNotFound     = errors.New(\"resource not found\")\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    ErrInvalidInput = errors.New(\"invalid input\")\n)\n```"
    },
    {
      "en-US": "### Error Checking with errors.Is and errors.As",
      "zh-Hans": "### 使用 errors.Is 和 errors.As 检查错误"
    },
    {
      "en-US": "```go\nfunc HandleError(err error) {\n    // Check for specific error\n    if errors.Is(err, sql.ErrNoRows) {\n        log.Println(\"No records found\")\n        return\n    }\n\n    // Check for error type\n    var validationErr *ValidationError\n    if errors.As(err, &validationErr) {\n        log.Printf(\"Validation error on field %s: %s\",\n            validationErr.Field, validationErr.Message)\n        return\n    }\n\n    // Unknown error\n    log.Printf(\"Unexpected error: %v\", err)\n}\n```",
      "zh-Hans": "```go\nfunc HandleError(err error) {\n    // Check for specific error\n    if errors.Is(err, sql.ErrNoRows) {\n        log.Println(\"No records found\")\n        return\n    }\n\n    // Check for error type\n    var validationErr *ValidationError\n    if errors.As(err, &validationErr) {\n        log.Printf(\"Validation error on field %s: %s\",\n            validationErr.Field, validationErr.Message)\n        return\n    }\n\n    // Unknown error\n    log.Printf(\"Unexpected error: %v\", err)\n}\n```"
    },
    {
      "en-US": "### Never Ignore Errors",
      "zh-Hans": "### 永不忽略错误"
    },
    {
      "en-US": "```go\n// Bad: Ignoring error with blank identifier\nresult, _ := doSomething()\n\n// Good: Handle or explicitly document why it's safe to ignore\nresult, err := doSomething()\nif err != nil {\n    return err\n}\n\n// Acceptable: When error truly doesn't matter (rare)\n_ = writer.Close() // Best-effort cleanup, error logged elsewhere\n```",
      "zh-Hans": "```go\n// Bad: Ignoring error with blank identifier\nresult, _ := doSomething()\n\n// Good: Handle or explicitly document why it's safe to ignore\nresult, err := doSomething()\nif err != nil {\n    return err\n}\n\n// Acceptable: When error truly doesn't matter (rare)\n_ = writer.Close() // Best-effort cleanup, error logged elsewhere\n```"
    },
    {
      "en-US": "## Concurrency Patterns",
      "zh-Hans": "## 并发模式"
    },
    {
      "en-US": "### Worker Pool",
      "zh-Hans": "### 工作池"
    },
    {
      "en-US": "```go\nfunc WorkerPool(jobs <-chan Job, results chan<- Result, numWorkers int) {\n    var wg sync.WaitGroup\n\n    for i := 0; i < numWorkers; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for job := range jobs {\n                results <- process(job)\n            }\n        }()\n    }\n\n    wg.Wait()\n    close(results)\n}\n```",
      "zh-Hans": "```go\nfunc WorkerPool(jobs <-chan Job, results chan<- Result, numWorkers int) {\n    var wg sync.WaitGroup\n\n    for i := 0; i < numWorkers; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for job := range jobs {\n                results <- process(job)\n            }\n        }()\n    }\n\n    wg.Wait()\n    close(results)\n}\n```"
    },
    {
      "en-US": "### Context for Cancellation and Timeouts",
      "zh-Hans": "### 用于取消和超时的 Context"
    },
    {
      "en-US": "```go\nfunc FetchWithTimeout(ctx context.Context, url string) ([]byte, error) {\n    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n    defer cancel()\n\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"create request: %w\", err)\n    }\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"fetch %s: %w\", url, err)\n    }\n    defer resp.Body.Close()\n\n    return io.ReadAll(resp.Body)\n}\n```",
      "zh-Hans": "```go\nfunc FetchWithTimeout(ctx context.Context, url string) ([]byte, error) {\n    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n    defer cancel()\n\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"create request: %w\", err)\n    }\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"fetch %s: %w\", url, err)\n    }\n    defer resp.Body.Close()\n\n    return io.ReadAll(resp.Body)\n}\n```"
    },
    {
      "en-US": "### Graceful Shutdown",
      "zh-Hans": "### 优雅关闭"
    },
    {
      "en-US": "```go\nfunc GracefulShutdown(server *http.Server) {\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n    <-quit\n    log.Println(\"Shutting down server...\")\n\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(ctx); err != nil {\n        log.Fatalf(\"Server forced to shutdown: %v\", err)\n    }\n\n    log.Println(\"Server exited\")\n}\n```",
      "zh-Hans": "```go\nfunc GracefulShutdown(server *http.Server) {\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n    <-quit\n    log.Println(\"Shutting down server...\")\n\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(ctx); err != nil {\n        log.Fatalf(\"Server forced to shutdown: %v\", err)\n    }\n\n    log.Println(\"Server exited\")\n}\n```"
    },
    {
      "en-US": "### errgroup for Coordinated Goroutines",
      "zh-Hans": "### 用于协调 Goroutine 的 errgroup"
    },
    {
      "en-US": "```go\nimport \"golang.org/x/sync/errgroup\"\n\nfunc FetchAll(ctx context.Context, urls []string) ([][]byte, error) {\n    g, ctx := errgroup.WithContext(ctx)\n    results := make([][]byte, len(urls))\n\n    for i, url := range urls {\n        i, url := i, url // Capture loop variables\n        g.Go(func() error {\n            data, err := FetchWithTimeout(ctx, url)\n            if err != nil {\n                return err\n            }\n            results[i] = data\n            return nil\n        })\n    }\n\n    if err := g.Wait(); err != nil {\n        return nil, err\n    }\n    return results, nil\n}\n```",
      "zh-Hans": "```go\nimport \"golang.org/x/sync/errgroup\"\n\nfunc FetchAll(ctx context.Context, urls []string) ([][]byte, error) {\n    g, ctx := errgroup.WithContext(ctx)\n    results := make([][]byte, len(urls))\n\n    for i, url := range urls {\n        i, url := i, url // Capture loop variables\n        g.Go(func() error {\n            data, err := FetchWithTimeout(ctx, url)\n            if err != nil {\n                return err\n            }\n            results[i] = data\n            return nil\n        })\n    }\n\n    if err := g.Wait(); err != nil {\n        return nil, err\n    }\n    return results, nil\n}\n```"
    },
    {
      "en-US": "### Avoiding Goroutine Leaks",
      "zh-Hans": "### 避免 Goroutine 泄漏"
    },
    {
      "en-US": "```go\n// Bad: Goroutine leak if context is cancelled\nfunc leakyFetch(ctx context.Context, url string) <-chan []byte {\n    ch := make(chan []byte)\n    go func() {\n        data, _ := fetch(url)\n        ch <- data // Blocks forever if no receiver\n    }()\n    return ch\n}\n\n// Good: Properly handles cancellation\nfunc safeFetch(ctx context.Context, url string) <-chan []byte {\n    ch := make(chan []byte, 1) // Buffered channel\n    go func() {\n        data, err := fetch(url)\n        if err != nil {\n            return\n        }\n        select {\n        case ch <- data:\n        case <-ctx.Done():\n        }\n    }()\n    return ch\n}\n```",
      "zh-Hans": "```go\n// Bad: Goroutine leak if context is cancelled\nfunc leakyFetch(ctx context.Context, url string) <-chan []byte {\n    ch := make(chan []byte)\n    go func() {\n        data, _ := fetch(url)\n        ch <- data // Blocks forever if no receiver\n    }()\n    return ch\n}\n\n// Good: Properly handles cancellation\nfunc safeFetch(ctx context.Context, url string) <-chan []byte {\n    ch := make(chan []byte, 1) // Buffered channel\n    go func() {\n        data, err := fetch(url)\n        if err != nil {\n            return\n        }\n        select {\n        case ch <- data:\n        case <-ctx.Done():\n        }\n    }()\n    return ch\n}\n```"
    },
    {
      "en-US": "## Interface Design",
      "zh-Hans": "## 接口设计"
    },
    {
      "en-US": "### Small, Focused Interfaces",
      "zh-Hans": "### 小而专注的接口"
    },
    {
      "en-US": "```go\n// Good: Single-method interfaces\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Compose interfaces as needed\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n```",
      "zh-Hans": "```go\n// Good: Single-method interfaces\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype Closer interface {\n    Close() error\n}\n\n// Compose interfaces as needed\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n```"
    },
    {
      "en-US": "### Define Interfaces Where They're Used",
      "zh-Hans": "### 在接口使用处定义接口"
    },
    {
      "en-US": "```go\n// In the consumer package, not the provider\npackage service\n\n// UserStore defines what this service needs\ntype UserStore interface {\n    GetUser(id string) (*User, error)\n    SaveUser(user *User) error\n}\n\ntype Service struct {\n    store UserStore\n}\n\n// Concrete implementation can be in another package\n// It doesn't need to know about this interface\n```",
      "zh-Hans": "```go\n// In the consumer package, not the provider\npackage service\n\n// UserStore defines what this service needs\ntype UserStore interface {\n    GetUser(id string) (*User, error)\n    SaveUser(user *User) error\n}\n\ntype Service struct {\n    store UserStore\n}\n\n// Concrete implementation can be in another package\n// It doesn't need to know about this interface\n```"
    },
    {
      "en-US": "### Optional Behavior with Type Assertions",
      "zh-Hans": "### 使用类型断言实现可选行为"
    },
    {
      "en-US": "```go\ntype Flusher interface {\n    Flush() error\n}\n\nfunc WriteAndFlush(w io.Writer, data []byte) error {\n    if _, err := w.Write(data); err != nil {\n        return err\n    }\n\n    // Flush if supported\n    if f, ok := w.(Flusher); ok {\n        return f.Flush()\n    }\n    return nil\n}\n```",
      "zh-Hans": "```go\ntype Flusher interface {\n    Flush() error\n}\n\nfunc WriteAndFlush(w io.Writer, data []byte) error {\n    if _, err := w.Write(data); err != nil {\n        return err\n    }\n\n    // Flush if supported\n    if f, ok := w.(Flusher); ok {\n        return f.Flush()\n    }\n    return nil\n}\n```"
    },
    {
      "en-US": "## Package Organization",
      "zh-Hans": "## 包组织"
    },
    {
      "en-US": "### Standard Project Layout",
      "zh-Hans": "### 标准项目布局"
    },
    {
      "en-US": "```text\nmyproject/\n├── cmd/\n│   └── myapp/\n│       └── main.go           # Entry point\n├── internal/\n│   ├── handler/              # HTTP handlers\n│   ├── service/              # Business logic\n│   ├── repository/           # Data access\n│   └── config/               # Configuration\n├── pkg/\n│   └── client/               # Public API client\n├── api/\n│   └── v1/                   # API definitions (proto, OpenAPI)\n├── testdata/                 # Test fixtures\n├── go.mod\n├── go.sum\n└── Makefile\n```",
      "zh-Hans": "```text\nmyproject/\n├── cmd/\n│   └── myapp/\n│       └── main.go           # Entry point\n├── internal/\n│   ├── handler/              # HTTP handlers\n│   ├── service/              # Business logic\n│   ├── repository/           # Data access\n│   └── config/               # Configuration\n├── pkg/\n│   └── client/               # Public API client\n├── api/\n│   └── v1/                   # API definitions (proto, OpenAPI)\n├── testdata/                 # Test fixtures\n├── go.mod\n├── go.sum\n└── Makefile\n```"
    },
    {
      "en-US": "### Package Naming",
      "zh-Hans": "### 包命名"
    },
    {
      "en-US": "```go\n// Good: Short, lowercase, no underscores\npackage http\npackage json\npackage user\n\n// Bad: Verbose, mixed case, or redundant\npackage httpHandler\npackage json_parser\npackage userService // Redundant 'Service' suffix\n```",
      "zh-Hans": "```go\n// Good: Short, lowercase, no underscores\npackage http\npackage json\npackage user\n\n// Bad: Verbose, mixed case, or redundant\npackage httpHandler\npackage json_parser\npackage userService // Redundant 'Service' suffix\n```"
    },
    {
      "en-US": "### Avoid Package-Level State",
      "zh-Hans": "### 避免包级状态"
    },
    {
      "en-US": "```go\n// Bad: Global mutable state\nvar db *sql.DB\n\nfunc init() {\n    db, _ = sql.Open(\"postgres\", os.Getenv(\"DATABASE_URL\"))\n}\n\n// Good: Dependency injection\ntype Server struct {\n    db *sql.DB\n}\n\nfunc NewServer(db *sql.DB) *Server {\n    return &Server{db: db}\n}\n```",
      "zh-Hans": "```go\n// Bad: Global mutable state\nvar db *sql.DB\n\nfunc init() {\n    db, _ = sql.Open(\"postgres\", os.Getenv(\"DATABASE_URL\"))\n}\n\n// Good: Dependency injection\ntype Server struct {\n    db *sql.DB\n}\n\nfunc NewServer(db *sql.DB) *Server {\n    return &Server{db: db}\n}\n```"
    },
    {
      "en-US": "## Struct Design",
      "zh-Hans": "## 结构体设计"
    },
    {
      "en-US": "### Functional Options Pattern",
      "zh-Hans": "### 函数式选项模式"
    },
    {
      "en-US": "```go\ntype Server struct {\n    addr    string\n    timeout time.Duration\n    logger  *log.Logger\n}\n\ntype Option func(*Server)\n\nfunc WithTimeout(d time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = d\n    }\n}\n\nfunc WithLogger(l *log.Logger) Option {\n    return func(s *Server) {\n        s.logger = l\n    }\n}\n\nfunc NewServer(addr string, opts ...Option) *Server {\n    s := &Server{\n        addr:    addr,\n        timeout: 30 * time.Second, // default\n        logger:  log.Default(),    // default\n    }\n    for _, opt := range opts {\n        opt(s)\n    }\n    return s\n}\n\n// Usage\nserver := NewServer(\":8080\",\n    WithTimeout(60*time.Second),\n    WithLogger(customLogger),\n)\n```",
      "zh-Hans": "```go\ntype Server struct {\n    addr    string\n    timeout time.Duration\n    logger  *log.Logger\n}\n\ntype Option func(*Server)\n\nfunc WithTimeout(d time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = d\n    }\n}\n\nfunc WithLogger(l *log.Logger) Option {\n    return func(s *Server) {\n        s.logger = l\n    }\n}\n\nfunc NewServer(addr string, opts ...Option) *Server {\n    s := &Server{\n        addr:    addr,\n        timeout: 30 * time.Second, // default\n        logger:  log.Default(),    // default\n    }\n    for _, opt := range opts {\n        opt(s)\n    }\n    return s\n}\n\n// Usage\nserver := NewServer(\":8080\",\n    WithTimeout(60*time.Second),\n    WithLogger(customLogger),\n)\n```"
    },
    {
      "en-US": "### Embedding for Composition",
      "zh-Hans": "### 使用嵌入实现组合"
    },
    {
      "en-US": "```go\ntype Logger struct {\n    prefix string\n}\n\nfunc (l *Logger) Log(msg string) {\n    fmt.Printf(\"[%s] %s\\n\", l.prefix, msg)\n}\n\ntype Server struct {\n    *Logger // Embedding - Server gets Log method\n    addr    string\n}\n\nfunc NewServer(addr string) *Server {\n    return &Server{\n        Logger: &Logger{prefix: \"SERVER\"},\n        addr:   addr,\n    }\n}\n\n// Usage\ns := NewServer(\":8080\")\ns.Log(\"Starting...\") // Calls embedded Logger.Log\n```",
      "zh-Hans": "```go\ntype Logger struct {\n    prefix string\n}\n\nfunc (l *Logger) Log(msg string) {\n    fmt.Printf(\"[%s] %s\\n\", l.prefix, msg)\n}\n\ntype Server struct {\n    *Logger // Embedding - Server gets Log method\n    addr    string\n}\n\nfunc NewServer(addr string) *Server {\n    return &Server{\n        Logger: &Logger{prefix: \"SERVER\"},\n        addr:   addr,\n    }\n}\n\n// Usage\ns := NewServer(\":8080\")\ns.Log(\"Starting...\") // Calls embedded Logger.Log\n```"
    },
    {
      "en-US": "## Memory and Performance",
      "zh-Hans": "## 内存与性能"
    },
    {
      "en-US": "### Preallocate Slices When Size is Known",
      "zh-Hans": "### 当大小已知时预分配切片"
    },
    {
      "en-US": "```go\n// Bad: Grows slice multiple times\nfunc processItems(items []Item) []Result {\n    var results []Result\n    for _, item := range items {\n        results = append(results, process(item))\n    }\n    return results\n}\n\n// Good: Single allocation\nfunc processItems(items []Item) []Result {\n    results := make([]Result, 0, len(items))\n    for _, item := range items {\n        results = append(results, process(item))\n    }\n    return results\n}\n```",
      "zh-Hans": "```go\n// Bad: Grows slice multiple times\nfunc processItems(items []Item) []Result {\n    var results []Result\n    for _, item := range items {\n        results = append(results, process(item))\n    }\n    return results\n}\n\n// Good: Single allocation\nfunc processItems(items []Item) []Result {\n    results := make([]Result, 0, len(items))\n    for _, item := range items {\n        results = append(results, process(item))\n    }\n    return results\n}\n```"
    },
    {
      "en-US": "### Use sync.Pool for Frequent Allocations",
      "zh-Hans": "### 为频繁分配使用 sync.Pool"
    },
    {
      "en-US": "```go\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc ProcessRequest(data []byte) []byte {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n\n    buf.Write(data)\n    // Process...\n    return buf.Bytes()\n}\n```",
      "zh-Hans": "```go\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc ProcessRequest(data []byte) []byte {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n\n    buf.Write(data)\n    // Process...\n    return buf.Bytes()\n}\n```"
    },
    {
      "en-US": "### Avoid String Concatenation in Loops",
      "zh-Hans": "### 避免在循环中进行字符串拼接"
    },
    {
      "en-US": "```go\n// Bad: Creates many string allocations\nfunc join(parts []string) string {\n    var result string\n    for _, p := range parts {\n        result += p + \",\"\n    }\n    return result\n}\n\n// Good: Single allocation with strings.Builder\nfunc join(parts []string) string {\n    var sb strings.Builder\n    for i, p := range parts {\n        if i > 0 {\n            sb.WriteString(\",\")\n        }\n        sb.WriteString(p)\n    }\n    return sb.String()\n}\n\n// Best: Use standard library\nfunc join(parts []string) string {\n    return strings.Join(parts, \",\")\n}\n```",
      "zh-Hans": "```go\n// Bad: Creates many string allocations\nfunc join(parts []string) string {\n    var result string\n    for _, p := range parts {\n        result += p + \",\"\n    }\n    return result\n}\n\n// Good: Single allocation with strings.Builder\nfunc join(parts []string) string {\n    var sb strings.Builder\n    for i, p := range parts {\n        if i > 0 {\n            sb.WriteString(\",\")\n        }\n        sb.WriteString(p)\n    }\n    return sb.String()\n}\n\n// Best: Use standard library\nfunc join(parts []string) string {\n    return strings.Join(parts, \",\")\n}\n```"
    },
    {
      "en-US": "## Go Tooling Integration",
      "zh-Hans": "## Go 工具集成"
    },
    {
      "en-US": "### Essential Commands",
      "zh-Hans": "### 基本命令"
    },
    {
      "en-US": "```bash\n# Build and run\ngo build ./...\ngo run ./cmd/myapp\n\n# Testing\ngo test ./...\ngo test -race ./...\ngo test -cover ./...\n\n# Static analysis\ngo vet ./...\nstaticcheck ./...\ngolangci-lint run\n\n# Module management\ngo mod tidy\ngo mod verify\n\n# Formatting\ngofmt -w .\ngoimports -w .\n```",
      "zh-Hans": "```bash\n# Build and run\ngo build ./...\ngo run ./cmd/myapp\n\n# Testing\ngo test ./...\ngo test -race ./...\ngo test -cover ./...\n\n# Static analysis\ngo vet ./...\nstaticcheck ./...\ngolangci-lint run\n\n# Module management\ngo mod tidy\ngo mod verify\n\n# Formatting\ngofmt -w .\ngoimports -w .\n```"
    },
    {
      "en-US": "### Recommended Linter Configuration (.golangci.yml)",
      "zh-Hans": "### 推荐的 Linter 配置 (.golangci.yml)"
    },
    {
      "en-US": "```yaml\nlinters:\n  enable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n    - gofmt\n    - goimports\n    - misspell\n    - unconvert\n    - unparam\n\nlinters-settings:\n  errcheck:\n    check-type-assertions: true\n  govet:\n    check-shadowing: true\n\nissues:\n  exclude-use-default: false\n```",
      "zh-Hans": "```yaml\nlinters:\n  enable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n    - gofmt\n    - goimports\n    - misspell\n    - unconvert\n    - unparam\n\nlinters-settings:\n  errcheck:\n    check-type-assertions: true\n  govet:\n    check-shadowing: true\n\nissues:\n  exclude-use-default: false\n```"
    },
    {
      "en-US": "## Quick Reference: Go Idioms",
      "zh-Hans": "## 快速参考：Go 惯用法"
    },
    {
      "en-US": "| Idiom | Description |\n|-------|-------------|\n| Accept interfaces, return structs | Functions accept interface params, return concrete types |\n| Errors are values | Treat errors as first-class values, not exceptions |\n| Don't communicate by sharing memory | Use channels for coordination between goroutines |\n| Make the zero value useful | Types should work without explicit initialization |\n| A little copying is better than a little dependency | Avoid unnecessary external dependencies |\n| Clear is better than clever | Prioritize readability over cleverness |\n| gofmt is no one's favorite but everyone's friend | Always format with gofmt/goimports |\n| Return early | Handle errors first, keep happy path unindented |",
      "zh-Hans": "| 惯用法 | 描述 |\n|-------|-------------|\n| 接受接口，返回结构体 | 函数接受接口参数，返回具体类型 |\n| 错误即值 | 将错误视为一等值，而非异常 |\n| 不要通过共享内存来通信 | 使用通道在 goroutine 之间进行协调 |\n| 让零值变得有用 | 类型应无需显式初始化即可工作 |\n| 少量复制优于少量依赖 | 避免不必要的外部依赖 |\n| 清晰优于精巧 | 优先考虑可读性而非精巧性 |\n| gofmt 虽非最爱，但却是每个人的朋友 | 始终使用 gofmt/goimports 格式化代码 |\n| 提前返回 | 先处理错误，保持主逻辑路径无缩进 |"
    },
    {
      "en-US": "## Anti-Patterns to Avoid",
      "zh-Hans": "## 应避免的反模式"
    },
    {
      "en-US": "```go\n// Bad: Naked returns in long functions\nfunc process() (result int, err error) {\n    // ... 50 lines ...\n    return // What is being returned?\n}\n\n// Bad: Using panic for control flow\nfunc GetUser(id string) *User {\n    user, err := db.Find(id)\n    if err != nil {\n        panic(err) // Don't do this\n    }\n    return user\n}\n\n// Bad: Passing context in struct\ntype Request struct {\n    ctx context.Context // Context should be first param\n    ID  string\n}\n\n// Good: Context as first parameter\nfunc ProcessRequest(ctx context.Context, id string) error {\n    // ...\n}\n\n// Bad: Mixing value and pointer receivers\ntype Counter struct{ n int }\nfunc (c Counter) Value() int { return c.n }    // Value receiver\nfunc (c *Counter) Increment() { c.n++ }        // Pointer receiver\n// Pick one style and be consistent\n```",
      "zh-Hans": "```go\n// Bad: Naked returns in long functions\nfunc process() (result int, err error) {\n    // ... 50 lines ...\n    return // What is being returned?\n}\n\n// Bad: Using panic for control flow\nfunc GetUser(id string) *User {\n    user, err := db.Find(id)\n    if err != nil {\n        panic(err) // Don't do this\n    }\n    return user\n}\n\n// Bad: Passing context in struct\ntype Request struct {\n    ctx context.Context // Context should be first param\n    ID  string\n}\n\n// Good: Context as first parameter\nfunc ProcessRequest(ctx context.Context, id string) error {\n    // ...\n}\n\n// Bad: Mixing value and pointer receivers\ntype Counter struct{ n int }\nfunc (c Counter) Value() int { return c.n }    // Value receiver\nfunc (c *Counter) Increment() { c.n++ }        // Pointer receiver\n// Pick one style and be consistent\n```"
    },
    {
      "en-US": "**Remember**: Go code should be boring in the best way - predictable, consistent, and easy to understand. When in doubt, keep it simple.",
      "zh-Hans": "**记住**：Go 代码应该以最好的方式显得“乏味”——可预测、一致且易于理解。如有疑问，保持简单。"
    }
  ]
}