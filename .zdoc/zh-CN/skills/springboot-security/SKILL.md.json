{
  "sourceFile": "skills/springboot-security/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: springboot-security\ndescription: Spring Security best practices for authn/authz, validation, CSRF, secrets, headers, rate limiting, and dependency security in Java Spring Boot services.\n---",
      "zh-Hans": "---\nname: springboot-security\ndescription: Java Spring Boot 服务中关于身份验证/授权、验证、CSRF、密钥、标头、速率限制和依赖安全的 Spring Security 最佳实践。\n---"
    },
    {
      "en-US": "# Spring Boot Security Review",
      "zh-Hans": "# Spring Boot 安全审查"
    },
    {
      "en-US": "Use when adding auth, handling input, creating endpoints, or dealing with secrets.",
      "zh-Hans": "在添加身份验证、处理输入、创建端点或处理密钥时使用。"
    },
    {
      "en-US": "## Authentication",
      "zh-Hans": "## 身份验证"
    },
    {
      "en-US": "- Prefer stateless JWT or opaque tokens with revocation list\n- Use `httpOnly`, `Secure`, `SameSite=Strict` cookies for sessions\n- Validate tokens with `OncePerRequestFilter` or resource server",
      "zh-Hans": "* 优先使用无状态 JWT 或带有撤销列表的不透明令牌\n* 对于会话，使用 `httpOnly`、`Secure`、`SameSite=Strict` cookie\n* 使用 `OncePerRequestFilter` 或资源服务器验证令牌"
    },
    {
      "en-US": "```java\n@Component\npublic class JwtAuthFilter extends OncePerRequestFilter {\n  private final JwtService jwtService;\n\n  public JwtAuthFilter(JwtService jwtService) {\n    this.jwtService = jwtService;\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n    if (header != null && header.startsWith(\"Bearer \")) {\n      String token = header.substring(7);\n      Authentication auth = jwtService.authenticate(token);\n      SecurityContextHolder.getContext().setAuthentication(auth);\n    }\n    chain.doFilter(request, response);\n  }\n}\n```",
      "zh-Hans": "```java\n@Component\npublic class JwtAuthFilter extends OncePerRequestFilter {\n  private final JwtService jwtService;\n\n  public JwtAuthFilter(JwtService jwtService) {\n    this.jwtService = jwtService;\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n    if (header != null && header.startsWith(\"Bearer \")) {\n      String token = header.substring(7);\n      Authentication auth = jwtService.authenticate(token);\n      SecurityContextHolder.getContext().setAuthentication(auth);\n    }\n    chain.doFilter(request, response);\n  }\n}\n```"
    },
    {
      "en-US": "## Authorization",
      "zh-Hans": "## 授权"
    },
    {
      "en-US": "- Enable method security: `@EnableMethodSecurity`\n- Use `@PreAuthorize(\"hasRole('ADMIN')\")` or `@PreAuthorize(\"@authz.canEdit(#id)\")`\n- Deny by default; expose only required scopes",
      "zh-Hans": "* 启用方法安全：`@EnableMethodSecurity`\n* 使用 `@PreAuthorize(\"hasRole('ADMIN')\")` 或 `@PreAuthorize(\"@authz.canEdit(#id)\")`\n* 默认拒绝；仅公开必需的 scope"
    },
    {
      "en-US": "## Input Validation",
      "zh-Hans": "## 输入验证"
    },
    {
      "en-US": "- Use Bean Validation with `@Valid` on controllers\n- Apply constraints on DTOs: `@NotBlank`, `@Email`, `@Size`, custom validators\n- Sanitize any HTML with a whitelist before rendering",
      "zh-Hans": "* 在控制器上使用带有 `@Valid` 的 Bean 验证\n* 在 DTO 上应用约束：`@NotBlank`、`@Email`、`@Size`、自定义验证器\n* 在渲染之前使用白名单清理任何 HTML"
    },
    {
      "en-US": "## SQL Injection Prevention",
      "zh-Hans": "## SQL 注入预防"
    },
    {
      "en-US": "- Use Spring Data repositories or parameterized queries\n- For native queries, use `:param` bindings; never concatenate strings",
      "zh-Hans": "* 使用 Spring Data 存储库或参数化查询\n* 对于原生查询，使用 `:param` 绑定；切勿拼接字符串"
    },
    {
      "en-US": "## CSRF Protection",
      "zh-Hans": "## CSRF 保护"
    },
    {
      "en-US": "- For browser session apps, keep CSRF enabled; include token in forms/headers\n- For pure APIs with Bearer tokens, disable CSRF and rely on stateless auth",
      "zh-Hans": "* 对于浏览器会话应用程序，保持 CSRF 启用；在表单/头中包含令牌\n* 对于使用 Bearer 令牌的纯 API，禁用 CSRF 并依赖无状态身份验证"
    },
    {
      "en-US": "```java\nhttp\n  .csrf(csrf -> csrf.disable())\n  .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n```",
      "zh-Hans": "```java\nhttp\n  .csrf(csrf -> csrf.disable())\n  .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n```"
    },
    {
      "en-US": "## Secrets Management",
      "zh-Hans": "## 密钥管理"
    },
    {
      "en-US": "- No secrets in source; load from env or vault\n- Keep `application.yml` free of credentials; use placeholders\n- Rotate tokens and DB credentials regularly",
      "zh-Hans": "* 源代码中不包含密钥；从环境变量或 vault 加载\n* 保持 `application.yml` 不包含凭据；使用占位符\n* 定期轮换令牌和数据库凭据"
    },
    {
      "en-US": "## Security Headers",
      "zh-Hans": "## 安全头"
    },
    {
      "en-US": "```java\nhttp\n  .headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n      .policyDirectives(\"default-src 'self'\"))\n    .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin)\n    .xssProtection(Customizer.withDefaults())\n    .referrerPolicy(rp -> rp.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER)));\n```",
      "zh-Hans": "```java\nhttp\n  .headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n      .policyDirectives(\"default-src 'self'\"))\n    .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin)\n    .xssProtection(Customizer.withDefaults())\n    .referrerPolicy(rp -> rp.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER)));\n```"
    },
    {
      "en-US": "## Rate Limiting",
      "zh-Hans": "## 速率限制"
    },
    {
      "en-US": "- Apply Bucket4j or gateway-level limits on expensive endpoints\n- Log and alert on bursts; return 429 with retry hints",
      "zh-Hans": "* 在昂贵的端点上应用 Bucket4j 或网关级限制\n* 记录突发流量并告警；返回 429 并提供重试提示"
    },
    {
      "en-US": "## Dependency Security",
      "zh-Hans": "## 依赖项安全"
    },
    {
      "en-US": "- Run OWASP Dependency Check / Snyk in CI\n- Keep Spring Boot and Spring Security on supported versions\n- Fail builds on known CVEs",
      "zh-Hans": "* 在 CI 中运行 OWASP Dependency Check / Snyk\n* 保持 Spring Boot 和 Spring Security 在受支持的版本\n* 对已知 CVE 使构建失败"
    },
    {
      "en-US": "## Logging and PII",
      "zh-Hans": "## 日志记录和 PII"
    },
    {
      "en-US": "- Never log secrets, tokens, passwords, or full PAN data\n- Redact sensitive fields; use structured JSON logging",
      "zh-Hans": "* 切勿记录密钥、令牌、密码或完整的 PAN 数据\n* 擦除敏感字段；使用结构化 JSON 日志记录"
    },
    {
      "en-US": "## File Uploads",
      "zh-Hans": "## 文件上传"
    },
    {
      "en-US": "- Validate size, content type, and extension\n- Store outside web root; scan if required",
      "zh-Hans": "* 验证大小、内容类型和扩展名\n* 存储在 Web 根目录之外；如果需要则进行扫描"
    },
    {
      "en-US": "## Checklist Before Release",
      "zh-Hans": "## 发布前检查清单"
    },
    {
      "en-US": "- [ ] Auth tokens validated and expired correctly\n- [ ] Authorization guards on every sensitive path\n- [ ] All inputs validated and sanitized\n- [ ] No string-concatenated SQL\n- [ ] CSRF posture correct for app type\n- [ ] Secrets externalized; none committed\n- [ ] Security headers configured\n- [ ] Rate limiting on APIs\n- [ ] Dependencies scanned and up to date\n- [ ] Logs free of sensitive data",
      "zh-Hans": "* \\[ ] 身份验证令牌已验证并正确过期\n* \\[ ] 每个敏感路径都有授权守卫\n* \\[ ] 所有输入都已验证和清理\n* \\[ ] 没有字符串拼接的 SQL\n* \\[ ] CSRF 策略适用于应用程序类型\n* \\[ ] 密钥已外部化；未提交任何密钥\n* \\[ ] 安全头已配置\n* \\[ ] API 有速率限制\n* \\[ ] 依赖项已扫描并保持最新\n* \\[ ] 日志不包含敏感数据"
    },
    {
      "en-US": "**Remember**: Deny by default, validate inputs, least privilege, and secure-by-configuration first.",
      "zh-Hans": "**记住**：默认拒绝、验证输入、最小权限、优先采用安全配置。"
    }
  ]
}