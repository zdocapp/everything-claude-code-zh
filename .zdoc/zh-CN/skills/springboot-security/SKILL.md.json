{
  "sourceFile": "skills/springboot-security/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: springboot-security\ndescription: Spring Security best practices for authn/authz, validation, CSRF, secrets, headers, rate limiting, and dependency security in Java Spring Boot services.\norigin: ECC\n---",
      "zh-Hans": "---\nname: springboot-security\ndescription: Java Spring Boot 服务中认证/授权、验证、CSRF、密钥、标头、速率限制和依赖安全性的 Spring Security 最佳实践。\norigin: ECC\n---"
    },
    {
      "en-US": "# Spring Boot Security Review",
      "zh-Hans": "# Spring Boot 安全审查"
    },
    {
      "en-US": "Use when adding auth, handling input, creating endpoints, or dealing with secrets.",
      "zh-Hans": "在添加身份验证、处理输入、创建端点或处理密钥时使用。"
    },
    {
      "en-US": "## When to Activate",
      "zh-Hans": "## 何时激活"
    },
    {
      "en-US": "- Adding authentication (JWT, OAuth2, session-based)\n- Implementing authorization (@PreAuthorize, role-based access)\n- Validating user input (Bean Validation, custom validators)\n- Configuring CORS, CSRF, or security headers\n- Managing secrets (Vault, environment variables)\n- Adding rate limiting or brute-force protection\n- Scanning dependencies for CVEs",
      "zh-Hans": "* 添加身份验证（JWT、OAuth2、基于会话）\n* 实现授权（@PreAuthorize、基于角色的访问控制）\n* 验证用户输入（Bean Validation、自定义验证器）\n* 配置 CORS、CSRF 或安全标头\n* 管理密钥（Vault、环境变量）\n* 添加速率限制或暴力破解防护\n* 扫描依赖项以查找 CVE"
    },
    {
      "en-US": "## Authentication",
      "zh-Hans": "## 身份验证"
    },
    {
      "en-US": "- Prefer stateless JWT or opaque tokens with revocation list\n- Use `httpOnly`, `Secure`, `SameSite=Strict` cookies for sessions\n- Validate tokens with `OncePerRequestFilter` or resource server",
      "zh-Hans": "* 优先使用无状态 JWT 或带有撤销列表的不透明令牌\n* 对于会话，使用 `httpOnly`、`Secure`、`SameSite=Strict` cookie\n* 使用 `OncePerRequestFilter` 或资源服务器验证令牌"
    },
    {
      "en-US": "```java\n@Component\npublic class JwtAuthFilter extends OncePerRequestFilter {\n  private final JwtService jwtService;\n\n  public JwtAuthFilter(JwtService jwtService) {\n    this.jwtService = jwtService;\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n    if (header != null && header.startsWith(\"Bearer \")) {\n      String token = header.substring(7);\n      Authentication auth = jwtService.authenticate(token);\n      SecurityContextHolder.getContext().setAuthentication(auth);\n    }\n    chain.doFilter(request, response);\n  }\n}\n```",
      "zh-Hans": "```java\n@Component\npublic class JwtAuthFilter extends OncePerRequestFilter {\n  private final JwtService jwtService;\n\n  public JwtAuthFilter(JwtService jwtService) {\n    this.jwtService = jwtService;\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n    if (header != null && header.startsWith(\"Bearer \")) {\n      String token = header.substring(7);\n      Authentication auth = jwtService.authenticate(token);\n      SecurityContextHolder.getContext().setAuthentication(auth);\n    }\n    chain.doFilter(request, response);\n  }\n}\n```"
    },
    {
      "en-US": "## Authorization",
      "zh-Hans": "## 授权"
    },
    {
      "en-US": "- Enable method security: `@EnableMethodSecurity`\n- Use `@PreAuthorize(\"hasRole('ADMIN')\")` or `@PreAuthorize(\"@authz.canEdit(#id)\")`\n- Deny by default; expose only required scopes",
      "zh-Hans": "* 启用方法安全：`@EnableMethodSecurity`\n* 使用 `@PreAuthorize(\"hasRole('ADMIN')\")` 或 `@PreAuthorize(\"@authz.canEdit(#id)\")`\n* 默认拒绝；仅公开必需的 scope"
    },
    {
      "en-US": "```java\n@RestController\n@RequestMapping(\"/api/admin\")\npublic class AdminController {\n\n  @PreAuthorize(\"hasRole('ADMIN')\")\n  @GetMapping(\"/users\")\n  public List<UserDto> listUsers() {\n    return userService.findAll();\n  }\n\n  @PreAuthorize(\"@authz.isOwner(#id, authentication)\")\n  @DeleteMapping(\"/users/{id}\")\n  public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n    userService.delete(id);\n    return ResponseEntity.noContent().build();\n  }\n}\n```",
      "zh-Hans": "```java\n@RestController\n@RequestMapping(\"/api/admin\")\npublic class AdminController {\n\n  @PreAuthorize(\"hasRole('ADMIN')\")\n  @GetMapping(\"/users\")\n  public List<UserDto> listUsers() {\n    return userService.findAll();\n  }\n\n  @PreAuthorize(\"@authz.isOwner(#id, authentication)\")\n  @DeleteMapping(\"/users/{id}\")\n  public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n    userService.delete(id);\n    return ResponseEntity.noContent().build();\n  }\n}\n```"
    },
    {
      "en-US": "## Input Validation",
      "zh-Hans": "## 输入验证"
    },
    {
      "en-US": "- Use Bean Validation with `@Valid` on controllers\n- Apply constraints on DTOs: `@NotBlank`, `@Email`, `@Size`, custom validators\n- Sanitize any HTML with a whitelist before rendering",
      "zh-Hans": "* 在控制器上使用带有 `@Valid` 的 Bean 验证\n* 在 DTO 上应用约束：`@NotBlank`、`@Email`、`@Size`、自定义验证器\n* 在渲染之前使用白名单清理任何 HTML"
    },
    {
      "en-US": "```java\n// BAD: No validation\n@PostMapping(\"/users\")\npublic User createUser(@RequestBody UserDto dto) {\n  return userService.create(dto);\n}\n\n// GOOD: Validated DTO\npublic record CreateUserDto(\n    @NotBlank @Size(max = 100) String name,\n    @NotBlank @Email String email,\n    @NotNull @Min(0) @Max(150) Integer age\n) {}\n\n@PostMapping(\"/users\")\npublic ResponseEntity<UserDto> createUser(@Valid @RequestBody CreateUserDto dto) {\n  return ResponseEntity.status(HttpStatus.CREATED)\n      .body(userService.create(dto));\n}\n```",
      "zh-Hans": "```java\n// BAD: No validation\n@PostMapping(\"/users\")\npublic User createUser(@RequestBody UserDto dto) {\n  return userService.create(dto);\n}\n\n// GOOD: Validated DTO\npublic record CreateUserDto(\n    @NotBlank @Size(max = 100) String name,\n    @NotBlank @Email String email,\n    @NotNull @Min(0) @Max(150) Integer age\n) {}\n\n@PostMapping(\"/users\")\npublic ResponseEntity<UserDto> createUser(@Valid @RequestBody CreateUserDto dto) {\n  return ResponseEntity.status(HttpStatus.CREATED)\n      .body(userService.create(dto));\n}\n```"
    },
    {
      "en-US": "## SQL Injection Prevention",
      "zh-Hans": "## SQL 注入预防"
    },
    {
      "en-US": "- Use Spring Data repositories or parameterized queries\n- For native queries, use `:param` bindings; never concatenate strings",
      "zh-Hans": "* 使用 Spring Data 存储库或参数化查询\n* 对于原生查询，使用 `:param` 绑定；切勿拼接字符串"
    },
    {
      "en-US": "```java\n// BAD: String concatenation in native query\n@Query(value = \"SELECT * FROM users WHERE name = '\" + name + \"'\", nativeQuery = true)\n\n// GOOD: Parameterized native query\n@Query(value = \"SELECT * FROM users WHERE name = :name\", nativeQuery = true)\nList<User> findByName(@Param(\"name\") String name);\n\n// GOOD: Spring Data derived query (auto-parameterized)\nList<User> findByEmailAndActiveTrue(String email);\n```",
      "zh-Hans": "```java\n// BAD: String concatenation in native query\n@Query(value = \"SELECT * FROM users WHERE name = '\" + name + \"'\", nativeQuery = true)\n\n// GOOD: Parameterized native query\n@Query(value = \"SELECT * FROM users WHERE name = :name\", nativeQuery = true)\nList<User> findByName(@Param(\"name\") String name);\n\n// GOOD: Spring Data derived query (auto-parameterized)\nList<User> findByEmailAndActiveTrue(String email);\n```"
    },
    {
      "en-US": "## Password Encoding",
      "zh-Hans": "## 密码编码"
    },
    {
      "en-US": "- Always hash passwords with BCrypt or Argon2 — never store plaintext\n- Use `PasswordEncoder` bean, not manual hashing",
      "zh-Hans": "* 始终使用 BCrypt 或 Argon2 哈希密码——切勿存储明文\n* 使用 `PasswordEncoder` Bean，而非手动哈希"
    },
    {
      "en-US": "```java\n@Bean\npublic PasswordEncoder passwordEncoder() {\n  return new BCryptPasswordEncoder(12); // cost factor 12\n}\n\n// In service\npublic User register(CreateUserDto dto) {\n  String hashedPassword = passwordEncoder.encode(dto.password());\n  return userRepository.save(new User(dto.email(), hashedPassword));\n}\n```",
      "zh-Hans": "```java\n@Bean\npublic PasswordEncoder passwordEncoder() {\n  return new BCryptPasswordEncoder(12); // cost factor 12\n}\n\n// In service\npublic User register(CreateUserDto dto) {\n  String hashedPassword = passwordEncoder.encode(dto.password());\n  return userRepository.save(new User(dto.email(), hashedPassword));\n}\n```"
    },
    {
      "en-US": "## CSRF Protection",
      "zh-Hans": "## CSRF 保护"
    },
    {
      "en-US": "- For browser session apps, keep CSRF enabled; include token in forms/headers\n- For pure APIs with Bearer tokens, disable CSRF and rely on stateless auth",
      "zh-Hans": "* 对于浏览器会话应用程序，保持 CSRF 启用；在表单/头中包含令牌\n* 对于使用 Bearer 令牌的纯 API，禁用 CSRF 并依赖无状态身份验证"
    },
    {
      "en-US": "```java\nhttp\n  .csrf(csrf -> csrf.disable())\n  .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n```",
      "zh-Hans": "```java\nhttp\n  .csrf(csrf -> csrf.disable())\n  .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n```"
    },
    {
      "en-US": "## Secrets Management",
      "zh-Hans": "## 密钥管理"
    },
    {
      "en-US": "- No secrets in source; load from env or vault\n- Keep `application.yml` free of credentials; use placeholders\n- Rotate tokens and DB credentials regularly",
      "zh-Hans": "* 源代码中不包含密钥；从环境变量或 vault 加载\n* 保持 `application.yml` 不包含凭据；使用占位符\n* 定期轮换令牌和数据库凭据"
    },
    {
      "en-US": "```yaml\n# BAD: Hardcoded in application.yml\nspring:\n  datasource:\n    password: mySecretPassword123\n\n# GOOD: Environment variable placeholder\nspring:\n  datasource:\n    password: ${DB_PASSWORD}\n\n# GOOD: Spring Cloud Vault integration\nspring:\n  cloud:\n    vault:\n      uri: https://vault.example.com\n      token: ${VAULT_TOKEN}\n```",
      "zh-Hans": "```yaml\n# BAD: Hardcoded in application.yml\nspring:\n  datasource:\n    password: mySecretPassword123\n\n# GOOD: Environment variable placeholder\nspring:\n  datasource:\n    password: ${DB_PASSWORD}\n\n# GOOD: Spring Cloud Vault integration\nspring:\n  cloud:\n    vault:\n      uri: https://vault.example.com\n      token: ${VAULT_TOKEN}\n```"
    },
    {
      "en-US": "## Security Headers",
      "zh-Hans": "## 安全头"
    },
    {
      "en-US": "```java\nhttp\n  .headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n      .policyDirectives(\"default-src 'self'\"))\n    .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin)\n    .xssProtection(Customizer.withDefaults())\n    .referrerPolicy(rp -> rp.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER)));\n```",
      "zh-Hans": "```java\nhttp\n  .headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n      .policyDirectives(\"default-src 'self'\"))\n    .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin)\n    .xssProtection(Customizer.withDefaults())\n    .referrerPolicy(rp -> rp.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER)));\n```"
    },
    {
      "en-US": "## CORS Configuration",
      "zh-Hans": "## CORS 配置"
    },
    {
      "en-US": "- Configure CORS at the security filter level, not per-controller\n- Restrict allowed origins — never use `*` in production",
      "zh-Hans": "* 在安全过滤器级别配置 CORS，而非按控制器配置\n* 限制允许的来源——在生产环境中切勿使用 `*`"
    },
    {
      "en-US": "```java\n@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n  CorsConfiguration config = new CorsConfiguration();\n  config.setAllowedOrigins(List.of(\"https://app.example.com\"));\n  config.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n  config.setAllowedHeaders(List.of(\"Authorization\", \"Content-Type\"));\n  config.setAllowCredentials(true);\n  config.setMaxAge(3600L);\n\n  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n  source.registerCorsConfiguration(\"/api/**\", config);\n  return source;\n}\n\n// In SecurityFilterChain:\nhttp.cors(cors -> cors.configurationSource(corsConfigurationSource()));\n```",
      "zh-Hans": "```java\n@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n  CorsConfiguration config = new CorsConfiguration();\n  config.setAllowedOrigins(List.of(\"https://app.example.com\"));\n  config.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n  config.setAllowedHeaders(List.of(\"Authorization\", \"Content-Type\"));\n  config.setAllowCredentials(true);\n  config.setMaxAge(3600L);\n\n  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n  source.registerCorsConfiguration(\"/api/**\", config);\n  return source;\n}\n\n// In SecurityFilterChain:\nhttp.cors(cors -> cors.configurationSource(corsConfigurationSource()));\n```"
    },
    {
      "en-US": "## Rate Limiting",
      "zh-Hans": "## 速率限制"
    },
    {
      "en-US": "- Apply Bucket4j or gateway-level limits on expensive endpoints\n- Log and alert on bursts; return 429 with retry hints",
      "zh-Hans": "* 在昂贵的端点上应用 Bucket4j 或网关级限制\n* 记录突发流量并告警；返回 429 并提供重试提示"
    },
    {
      "en-US": "```java\n// Using Bucket4j for per-endpoint rate limiting\n@Component\npublic class RateLimitFilter extends OncePerRequestFilter {\n  private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();\n\n  private Bucket createBucket() {\n    return Bucket.builder()\n        .addLimit(Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1))))\n        .build();\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String clientIp = request.getRemoteAddr();\n    Bucket bucket = buckets.computeIfAbsent(clientIp, k -> createBucket());\n\n    if (bucket.tryConsume(1)) {\n      chain.doFilter(request, response);\n    } else {\n      response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n      response.getWriter().write(\"{\\\"error\\\": \\\"Rate limit exceeded\\\"}\");\n    }\n  }\n}\n```",
      "zh-Hans": "```java\n// Using Bucket4j for per-endpoint rate limiting\n@Component\npublic class RateLimitFilter extends OncePerRequestFilter {\n  private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();\n\n  private Bucket createBucket() {\n    return Bucket.builder()\n        .addLimit(Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1))))\n        .build();\n  }\n\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n      FilterChain chain) throws ServletException, IOException {\n    String clientIp = request.getRemoteAddr();\n    Bucket bucket = buckets.computeIfAbsent(clientIp, k -> createBucket());\n\n    if (bucket.tryConsume(1)) {\n      chain.doFilter(request, response);\n    } else {\n      response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n      response.getWriter().write(\"{\\\"error\\\": \\\"Rate limit exceeded\\\"}\");\n    }\n  }\n}\n```"
    },
    {
      "en-US": "## Dependency Security",
      "zh-Hans": "## 依赖项安全"
    },
    {
      "en-US": "- Run OWASP Dependency Check / Snyk in CI\n- Keep Spring Boot and Spring Security on supported versions\n- Fail builds on known CVEs",
      "zh-Hans": "* 在 CI 中运行 OWASP Dependency Check / Snyk\n* 保持 Spring Boot 和 Spring Security 在受支持的版本\n* 对已知 CVE 使构建失败"
    },
    {
      "en-US": "## Logging and PII",
      "zh-Hans": "## 日志记录和 PII"
    },
    {
      "en-US": "- Never log secrets, tokens, passwords, or full PAN data\n- Redact sensitive fields; use structured JSON logging",
      "zh-Hans": "* 切勿记录密钥、令牌、密码或完整的 PAN 数据\n* 擦除敏感字段；使用结构化 JSON 日志记录"
    },
    {
      "en-US": "## File Uploads",
      "zh-Hans": "## 文件上传"
    },
    {
      "en-US": "- Validate size, content type, and extension\n- Store outside web root; scan if required",
      "zh-Hans": "* 验证大小、内容类型和扩展名\n* 存储在 Web 根目录之外；如果需要则进行扫描"
    },
    {
      "en-US": "## Checklist Before Release",
      "zh-Hans": "## 发布前检查清单"
    },
    {
      "en-US": "- [ ] Auth tokens validated and expired correctly\n- [ ] Authorization guards on every sensitive path\n- [ ] All inputs validated and sanitized\n- [ ] No string-concatenated SQL\n- [ ] CSRF posture correct for app type\n- [ ] Secrets externalized; none committed\n- [ ] Security headers configured\n- [ ] Rate limiting on APIs\n- [ ] Dependencies scanned and up to date\n- [ ] Logs free of sensitive data",
      "zh-Hans": "* \\[ ] 身份验证令牌已验证并正确过期\n* \\[ ] 每个敏感路径都有授权守卫\n* \\[ ] 所有输入都已验证和清理\n* \\[ ] 没有字符串拼接的 SQL\n* \\[ ] CSRF 策略适用于应用程序类型\n* \\[ ] 密钥已外部化；未提交任何密钥\n* \\[ ] 安全头已配置\n* \\[ ] API 有速率限制\n* \\[ ] 依赖项已扫描并保持最新\n* \\[ ] 日志不包含敏感数据"
    },
    {
      "en-US": "**Remember**: Deny by default, validate inputs, least privilege, and secure-by-configuration first.",
      "zh-Hans": "**记住**：默认拒绝、验证输入、最小权限、优先采用安全配置。"
    }
  ]
}