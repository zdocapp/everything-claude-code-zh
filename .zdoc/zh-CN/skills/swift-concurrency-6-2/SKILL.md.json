{
  "sourceFile": "skills/swift-concurrency-6-2/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: swift-concurrency-6-2\ndescription: Swift 6.2 Approachable Concurrency — single-threaded by default, @concurrent for explicit background offloading, isolated conformances for main actor types.\n---",
      "zh-Hans": "---\nname: swift-concurrency-6-2\ndescription: Swift 6.2 可接近的并发性 — 默认单线程，@concurrent 用于显式后台卸载，隔离一致性用于主 actor 类型。\n---"
    },
    {
      "en-US": "# Swift 6.2 Approachable Concurrency",
      "zh-Hans": "# Swift 6.2 可接近的并发"
    },
    {
      "en-US": "Patterns for adopting Swift 6.2's concurrency model where code runs single-threaded by default and concurrency is introduced explicitly. Eliminates common data-race errors without sacrificing performance.",
      "zh-Hans": "采用 Swift 6.2 并发模型的模式，其中代码默认在单线程上运行，并发是显式引入的。在无需牺牲性能的情况下消除常见的数据竞争错误。"
    },
    {
      "en-US": "## When to Activate",
      "zh-Hans": "## 何时启用"
    },
    {
      "en-US": "- Migrating Swift 5.x or 6.0/6.1 projects to Swift 6.2\n- Resolving data-race safety compiler errors\n- Designing MainActor-based app architecture\n- Offloading CPU-intensive work to background threads\n- Implementing protocol conformances on MainActor-isolated types\n- Enabling Approachable Concurrency build settings in Xcode 26",
      "zh-Hans": "* 将 Swift 5.x 或 6.0/6.1 项目迁移到 Swift 6.2\n* 解决数据竞争安全编译器错误\n* 设计基于 MainActor 的应用架构\n* 将 CPU 密集型工作卸载到后台线程\n* 在 MainActor 隔离的类型上实现协议一致性\n* 在 Xcode 26 中启用“可接近的并发”构建设置"
    },
    {
      "en-US": "## Core Problem: Implicit Background Offloading",
      "zh-Hans": "## 核心问题：隐式的后台卸载"
    },
    {
      "en-US": "In Swift 6.1 and earlier, async functions could be implicitly offloaded to background threads, causing data-race errors even in seemingly safe code:",
      "zh-Hans": "在 Swift 6.1 及更早版本中，异步函数可能会被隐式卸载到后台线程，即使在看似安全的代码中也会导致数据竞争错误："
    },
    {
      "en-US": "```swift\n// Swift 6.1: ERROR\n@MainActor\nfinal class StickerModel {\n    let photoProcessor = PhotoProcessor()\n\n    func extractSticker(_ item: PhotosPickerItem) async throws -> Sticker? {\n        guard let data = try await item.loadTransferable(type: Data.self) else { return nil }\n\n        // Error: Sending 'self.photoProcessor' risks causing data races\n        return await photoProcessor.extractSticker(data: data, with: item.itemIdentifier)\n    }\n}\n```",
      "zh-Hans": "```swift\n// Swift 6.1: ERROR\n@MainActor\nfinal class StickerModel {\n    let photoProcessor = PhotoProcessor()\n\n    func extractSticker(_ item: PhotosPickerItem) async throws -> Sticker? {\n        guard let data = try await item.loadTransferable(type: Data.self) else { return nil }\n\n        // Error: Sending 'self.photoProcessor' risks causing data races\n        return await photoProcessor.extractSticker(data: data, with: item.itemIdentifier)\n    }\n}\n```"
    },
    {
      "en-US": "Swift 6.2 fixes this: async functions stay on the calling actor by default.",
      "zh-Hans": "Swift 6.2 修复了这个问题：异步函数默认保持在调用者所在的 actor 上。"
    },
    {
      "en-US": "```swift\n// Swift 6.2: OK — async stays on MainActor, no data race\n@MainActor\nfinal class StickerModel {\n    let photoProcessor = PhotoProcessor()\n\n    func extractSticker(_ item: PhotosPickerItem) async throws -> Sticker? {\n        guard let data = try await item.loadTransferable(type: Data.self) else { return nil }\n        return await photoProcessor.extractSticker(data: data, with: item.itemIdentifier)\n    }\n}\n```",
      "zh-Hans": "```swift\n// Swift 6.2: OK — async stays on MainActor, no data race\n@MainActor\nfinal class StickerModel {\n    let photoProcessor = PhotoProcessor()\n\n    func extractSticker(_ item: PhotosPickerItem) async throws -> Sticker? {\n        guard let data = try await item.loadTransferable(type: Data.self) else { return nil }\n        return await photoProcessor.extractSticker(data: data, with: item.itemIdentifier)\n    }\n}\n```"
    },
    {
      "en-US": "## Core Pattern — Isolated Conformances",
      "zh-Hans": "## 核心模式 — 隔离的一致性"
    },
    {
      "en-US": "MainActor types can now conform to non-isolated protocols safely:",
      "zh-Hans": "MainActor 类型现在可以安全地符合非隔离协议："
    },
    {
      "en-US": "```swift\nprotocol Exportable {\n    func export()\n}\n\n// Swift 6.1: ERROR — crosses into main actor-isolated code\n// Swift 6.2: OK with isolated conformance\nextension StickerModel: @MainActor Exportable {\n    func export() {\n        photoProcessor.exportAsPNG()\n    }\n}\n```",
      "zh-Hans": "```swift\nprotocol Exportable {\n    func export()\n}\n\n// Swift 6.1: ERROR — crosses into main actor-isolated code\n// Swift 6.2: OK with isolated conformance\nextension StickerModel: @MainActor Exportable {\n    func export() {\n        photoProcessor.exportAsPNG()\n    }\n}\n```"
    },
    {
      "en-US": "The compiler ensures the conformance is only used on the main actor:",
      "zh-Hans": "编译器确保该一致性仅在主 actor 上使用："
    },
    {
      "en-US": "```swift\n// OK — ImageExporter is also @MainActor\n@MainActor\nstruct ImageExporter {\n    var items: [any Exportable]\n\n    mutating func add(_ item: StickerModel) {\n        items.append(item)  // Safe: same actor isolation\n    }\n}\n\n// ERROR — nonisolated context can't use MainActor conformance\nnonisolated struct ImageExporter {\n    var items: [any Exportable]\n\n    mutating func add(_ item: StickerModel) {\n        items.append(item)  // Error: Main actor-isolated conformance cannot be used here\n    }\n}\n```",
      "zh-Hans": "```swift\n// OK — ImageExporter is also @MainActor\n@MainActor\nstruct ImageExporter {\n    var items: [any Exportable]\n\n    mutating func add(_ item: StickerModel) {\n        items.append(item)  // Safe: same actor isolation\n    }\n}\n\n// ERROR — nonisolated context can't use MainActor conformance\nnonisolated struct ImageExporter {\n    var items: [any Exportable]\n\n    mutating func add(_ item: StickerModel) {\n        items.append(item)  // Error: Main actor-isolated conformance cannot be used here\n    }\n}\n```"
    },
    {
      "en-US": "## Core Pattern — Global and Static Variables",
      "zh-Hans": "## 核心模式 — 全局和静态变量"
    },
    {
      "en-US": "Protect global/static state with MainActor:",
      "zh-Hans": "使用 MainActor 保护全局/静态状态："
    },
    {
      "en-US": "```swift\n// Swift 6.1: ERROR — non-Sendable type may have shared mutable state\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // Error\n}\n\n// Fix: Annotate with @MainActor\n@MainActor\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // OK\n}\n```",
      "zh-Hans": "```swift\n// Swift 6.1: ERROR — non-Sendable type may have shared mutable state\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // Error\n}\n\n// Fix: Annotate with @MainActor\n@MainActor\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // OK\n}\n```"
    },
    {
      "en-US": "### MainActor Default Inference Mode",
      "zh-Hans": "### MainActor 默认推断模式"
    },
    {
      "en-US": "Swift 6.2 introduces a mode where MainActor is inferred by default — no manual annotations needed:",
      "zh-Hans": "Swift 6.2 引入了一种模式，默认推断 MainActor — 无需手动标注："
    },
    {
      "en-US": "```swift\n// With MainActor default inference enabled:\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // Implicitly @MainActor\n}\n\nfinal class StickerModel {\n    let photoProcessor: PhotoProcessor\n    var selection: [PhotosPickerItem]  // Implicitly @MainActor\n}\n\nextension StickerModel: Exportable {  // Implicitly @MainActor conformance\n    func export() {\n        photoProcessor.exportAsPNG()\n    }\n}\n```",
      "zh-Hans": "```swift\n// With MainActor default inference enabled:\nfinal class StickerLibrary {\n    static let shared: StickerLibrary = .init()  // Implicitly @MainActor\n}\n\nfinal class StickerModel {\n    let photoProcessor: PhotoProcessor\n    var selection: [PhotosPickerItem]  // Implicitly @MainActor\n}\n\nextension StickerModel: Exportable {  // Implicitly @MainActor conformance\n    func export() {\n        photoProcessor.exportAsPNG()\n    }\n}\n```"
    },
    {
      "en-US": "This mode is opt-in and recommended for apps, scripts, and other executable targets.",
      "zh-Hans": "此模式是选择启用的，推荐用于应用、脚本和其他可执行目标。"
    },
    {
      "en-US": "## Core Pattern — @concurrent for Background Work",
      "zh-Hans": "## 核心模式 — 使用 @concurrent 进行后台工作"
    },
    {
      "en-US": "When you need actual parallelism, explicitly offload with `@concurrent`:",
      "zh-Hans": "当需要真正的并行性时，使用 `@concurrent` 显式卸载："
    },
    {
      "en-US": "> **Important:** This example requires Approachable Concurrency build settings — SE-0466 (MainActor default isolation) and SE-0461 (NonisolatedNonsendingByDefault). With these enabled, `extractSticker` stays on the caller's actor, making mutable state access safe. **Without these settings, this code has a data race** — the compiler will flag it.",
      "zh-Hans": "> **重要：** 此示例需要启用“可接近的并发”构建设置 — SE-0466 (MainActor 默认隔离) 和 SE-0461 (默认非隔离非发送)。启用这些设置后，`extractSticker` 会保持在调用者所在的 actor 上，使得可变状态的访问变得安全。**如果没有这些设置，此代码存在数据竞争** — 编译器会标记它。"
    },
    {
      "en-US": "```swift\nnonisolated final class PhotoProcessor {\n    private var cachedStickers: [String: Sticker] = [:]\n\n    func extractSticker(data: Data, with id: String) async -> Sticker {\n        if let sticker = cachedStickers[id] {\n            return sticker\n        }\n\n        let sticker = await Self.extractSubject(from: data)\n        cachedStickers[id] = sticker\n        return sticker\n    }\n\n    // Offload expensive work to concurrent thread pool\n    @concurrent\n    static func extractSubject(from data: Data) async -> Sticker { /* ... */ }\n}\n\n// Callers must await\nlet processor = PhotoProcessor()\nprocessedPhotos[item.id] = await processor.extractSticker(data: data, with: item.id)\n```",
      "zh-Hans": "```swift\nnonisolated final class PhotoProcessor {\n    private var cachedStickers: [String: Sticker] = [:]\n\n    func extractSticker(data: Data, with id: String) async -> Sticker {\n        if let sticker = cachedStickers[id] {\n            return sticker\n        }\n\n        let sticker = await Self.extractSubject(from: data)\n        cachedStickers[id] = sticker\n        return sticker\n    }\n\n    // Offload expensive work to concurrent thread pool\n    @concurrent\n    static func extractSubject(from data: Data) async -> Sticker { /* ... */ }\n}\n\n// Callers must await\nlet processor = PhotoProcessor()\nprocessedPhotos[item.id] = await processor.extractSticker(data: data, with: item.id)\n```"
    },
    {
      "en-US": "To use `@concurrent`:",
      "zh-Hans": "要使用 `@concurrent`："
    },
    {
      "en-US": "1. Mark the containing type as `nonisolated`\n2. Add `@concurrent` to the function\n3. Add `async` if not already asynchronous\n4. Add `await` at call sites",
      "zh-Hans": "1. 将包含类型标记为 `nonisolated`\n2. 向函数添加 `@concurrent`\n3. 如果函数还不是异步的，则添加 `async`\n4. 在调用点添加 `await`"
    },
    {
      "en-US": "## Key Design Decisions",
      "zh-Hans": "## 关键设计决策"
    },
    {
      "en-US": "| Decision | Rationale |\n|----------|-----------|\n| Single-threaded by default | Most natural code is data-race free; concurrency is opt-in |\n| Async stays on calling actor | Eliminates implicit offloading that caused data-race errors |\n| Isolated conformances | MainActor types can conform to protocols without unsafe workarounds |\n| `@concurrent` explicit opt-in | Background execution is a deliberate performance choice, not accidental |\n| MainActor default inference | Reduces boilerplate `@MainActor` annotations for app targets |\n| Opt-in adoption | Non-breaking migration path — enable features incrementally |",
      "zh-Hans": "| 决策 | 原理 |\n|----------|-----------|\n| 默认单线程 | 最自然的代码是无数据竞争的；并发是选择启用的 |\n| 异步函数保持在调用者所在的 actor 上 | 消除了导致数据竞争错误的隐式卸载 |\n| 隔离的一致性 | MainActor 类型可以符合协议，而无需不安全的变通方法 |\n| `@concurrent` 显式选择启用 | 后台执行是一种有意的性能选择，而非偶然 |\n| MainActor 默认推断 | 减少了应用目标中样板化的 `@MainActor` 标注 |\n| 选择启用采用 | 非破坏性的迁移路径 — 逐步启用功能 |"
    },
    {
      "en-US": "## Migration Steps",
      "zh-Hans": "## 迁移步骤"
    },
    {
      "en-US": "1. **Enable in Xcode**: Swift Compiler > Concurrency section in Build Settings\n2. **Enable in SPM**: Use `SwiftSettings` API in package manifest\n3. **Use migration tooling**: Automatic code changes via swift.org/migration\n4. **Start with MainActor defaults**: Enable inference mode for app targets\n5. **Add `@concurrent` where needed**: Profile first, then offload hot paths\n6. **Test thoroughly**: Data-race issues become compile-time errors",
      "zh-Hans": "1. **在 Xcode 中启用**：构建设置中的 Swift Compiler > Concurrency 部分\n2. **在 SPM 中启用**：在包清单中使用 `SwiftSettings` API\n3. **使用迁移工具**：通过 swift.org/migration 进行自动代码更改\n4. **从 MainActor 默认值开始**：为应用目标启用推断模式\n5. **在需要的地方添加 `@concurrent`**：先进行性能分析，然后卸载热点路径\n6. **彻底测试**：数据竞争问题会变成编译时错误"
    },
    {
      "en-US": "## Best Practices",
      "zh-Hans": "## 最佳实践"
    },
    {
      "en-US": "- **Start on MainActor** — write single-threaded code first, optimize later\n- **Use `@concurrent` only for CPU-intensive work** — image processing, compression, complex computation\n- **Enable MainActor inference mode** for app targets that are mostly single-threaded\n- **Profile before offloading** — use Instruments to find actual bottlenecks\n- **Protect globals with MainActor** — global/static mutable state needs actor isolation\n- **Use isolated conformances** instead of `nonisolated` workarounds or `@Sendable` wrappers\n- **Migrate incrementally** — enable features one at a time in build settings",
      "zh-Hans": "* **从 MainActor 开始** — 先编写单线程代码，稍后再优化\n* **仅对 CPU 密集型工作使用 `@concurrent`** — 图像处理、压缩、复杂计算\n* **为主要是单线程的应用目标启用 MainActor 推断模式**\n* **在卸载前进行性能分析** — 使用 Instruments 查找实际的瓶颈\n* **使用 MainActor 保护全局变量** — 全局/静态可变状态需要 actor 隔离\n* **使用隔离的一致性**，而不是 `nonisolated` 变通方法或 `@Sendable` 包装器\n* **增量迁移** — 在构建设置中一次启用一个功能"
    },
    {
      "en-US": "## Anti-Patterns to Avoid",
      "zh-Hans": "## 应避免的反模式"
    },
    {
      "en-US": "- Applying `@concurrent` to every async function (most don't need background execution)\n- Using `nonisolated` to suppress compiler errors without understanding isolation\n- Keeping legacy `DispatchQueue` patterns when actors provide the same safety\n- Skipping `model.availability` checks in concurrency-related Foundation Models code\n- Fighting the compiler — if it reports a data race, the code has a real concurrency issue\n- Assuming all async code runs in the background (Swift 6.2 default: stays on calling actor)",
      "zh-Hans": "* 对每个异步函数都应用 `@concurrent`（大多数不需要后台执行）\n* 在不理解隔离的情况下使用 `nonisolated` 来抑制编译器错误\n* 当 actor 提供相同安全性时，仍保留遗留的 `DispatchQueue` 模式\n* 在并发相关的 Foundation Models 代码中跳过 `model.availability` 检查\n* 与编译器对抗 — 如果它报告数据竞争，代码就存在真正的并发问题\n* 假设所有异步代码都在后台运行（Swift 6.2 默认：保持在调用者所在的 actor 上）"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "- All new Swift 6.2+ projects (Approachable Concurrency is the recommended default)\n- Migrating existing apps from Swift 5.x or 6.0/6.1 concurrency\n- Resolving data-race safety compiler errors during Xcode 26 adoption\n- Building MainActor-centric app architectures (most UI apps)\n- Performance optimization — offloading specific heavy computations to background",
      "zh-Hans": "* 所有新的 Swift 6.2+ 项目（“可接近的并发”是推荐的默认设置）\n* 将现有应用从 Swift 5.x 或 6.0/6.1 并发迁移过来\n* 在采用 Xcode 26 期间解决数据竞争安全编译器错误\n* 构建以 MainActor 为中心的应用架构（大多数 UI 应用）\n* 性能优化 — 将特定的繁重计算卸载到后台"
    }
  ]
}