{
  "sourceFile": "skills/cpp-coding-standards/SKILL.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\nname: cpp-coding-standards\ndescription: C++ coding standards based on the C++ Core Guidelines (isocpp.github.io). Use when writing, reviewing, or refactoring C++ code to enforce modern, safe, and idiomatic practices.\norigin: ECC\n---",
      "zh-Hans": "---\nname: cpp-coding-standards\ndescription: 基于C++核心指南（isocpp.github.io）的C++编码标准。在编写、审查或重构C++代码时使用，以强制实施现代、安全和惯用的实践。\norigin: ECC\n---"
    },
    {
      "en-US": "# C++ Coding Standards (C++ Core Guidelines)",
      "zh-Hans": "# C++ 编码标准（C++ 核心准则）"
    },
    {
      "en-US": "Comprehensive coding standards for modern C++ (C++17/20/23) derived from the [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines). Enforces type safety, resource safety, immutability, and clarity.",
      "zh-Hans": "源自 [C++ 核心准则](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) 的现代 C++（C++17/20/23）综合编码标准。强制执行类型安全、资源安全、不变性和清晰性。"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "- Writing new C++ code (classes, functions, templates)\n- Reviewing or refactoring existing C++ code\n- Making architectural decisions in C++ projects\n- Enforcing consistent style across a C++ codebase\n- Choosing between language features (e.g., `enum` vs `enum class`, raw pointer vs smart pointer)",
      "zh-Hans": "* 编写新的 C++ 代码（类、函数、模板）\n* 审查或重构现有的 C++ 代码\n* 在 C++ 项目中做出架构决策\n* 在 C++ 代码库中强制执行一致的风格\n* 在语言特性之间做出选择（例如，`enum` 对比 `enum class`，原始指针对比智能指针）"
    },
    {
      "en-US": "### When NOT to Use",
      "zh-Hans": "### 何时不应使用"
    },
    {
      "en-US": "- Non-C++ projects\n- Legacy C codebases that cannot adopt modern C++ features\n- Embedded/bare-metal contexts where specific guidelines conflict with hardware constraints (adapt selectively)",
      "zh-Hans": "* 非 C++ 项目\n* 无法采用现代 C++ 特性的遗留 C 代码库\n* 特定准则与硬件限制冲突的嵌入式/裸机环境（选择性适配）"
    },
    {
      "en-US": "## Cross-Cutting Principles",
      "zh-Hans": "## 贯穿性原则"
    },
    {
      "en-US": "These themes recur across the entire guidelines and form the foundation:",
      "zh-Hans": "这些主题在整个准则中反复出现，并构成了基础："
    },
    {
      "en-US": "1. **RAII everywhere** (P.8, R.1, E.6, CP.20): Bind resource lifetime to object lifetime\n2. **Immutability by default** (P.10, Con.1-5, ES.25): Start with `const`/`constexpr`; mutability is the exception\n3. **Type safety** (P.4, I.4, ES.46-49, Enum.3): Use the type system to prevent errors at compile time\n4. **Express intent** (P.3, F.1, NL.1-2, T.10): Names, types, and concepts should communicate purpose\n5. **Minimize complexity** (F.2-3, ES.5, Per.4-5): Simple code is correct code\n6. **Value semantics over pointer semantics** (C.10, R.3-5, F.20, CP.31): Prefer returning by value and scoped objects",
      "zh-Hans": "1. **处处使用 RAII** (P.8, R.1, E.6, CP.20)：将资源生命周期绑定到对象生命周期\n2. **默认为不可变性** (P.10, Con.1-5, ES.25)：从 `const`/`constexpr` 开始；可变性是例外\n3. **类型安全** (P.4, I.4, ES.46-49, Enum.3)：使用类型系统在编译时防止错误\n4. **表达意图** (P.3, F.1, NL.1-2, T.10)：名称、类型和概念应传达目的\n5. **最小化复杂性** (F.2-3, ES.5, Per.4-5)：简单的代码就是正确的代码\n6. **值语义优于指针语义** (C.10, R.3-5, F.20, CP.31)：优先按值返回和作用域对象"
    },
    {
      "en-US": "## Philosophy & Interfaces (P.*, I.*)",
      "zh-Hans": "## 哲学与接口 (P.\\*, I.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **P.1** | Express ideas directly in code |\n| **P.3** | Express intent |\n| **P.4** | Ideally, a program should be statically type safe |\n| **P.5** | Prefer compile-time checking to run-time checking |\n| **P.8** | Don't leak any resources |\n| **P.10** | Prefer immutable data to mutable data |\n| **I.1** | Make interfaces explicit |\n| **I.2** | Avoid non-const global variables |\n| **I.4** | Make interfaces precisely and strongly typed |\n| **I.11** | Never transfer ownership by a raw pointer or reference |\n| **I.23** | Keep the number of function arguments low |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **P.1** | 直接在代码中表达想法 |\n| **P.3** | 表达意图 |\n| **P.4** | 理想情况下，程序应是静态类型安全的 |\n| **P.5** | 优先编译时检查而非运行时检查 |\n| **P.8** | 不要泄漏任何资源 |\n| **P.10** | 优先不可变数据而非可变数据 |\n| **I.1** | 使接口明确 |\n| **I.2** | 避免非 const 全局变量 |\n| **I.4** | 使接口精确且强类型化 |\n| **I.11** | 切勿通过原始指针或引用转移所有权 |\n| **I.23** | 保持函数参数数量少 |"
    },
    {
      "en-US": "### DO",
      "zh-Hans": "### 应该做"
    },
    {
      "en-US": "```cpp\n// P.10 + I.4: Immutable, strongly typed interface\nstruct Temperature {\n    double kelvin;\n};\n\nTemperature boil(const Temperature& water);\n```",
      "zh-Hans": "```cpp\n// P.10 + I.4: Immutable, strongly typed interface\nstruct Temperature {\n    double kelvin;\n};\n\nTemperature boil(const Temperature& water);\n```"
    },
    {
      "en-US": "### DON'T",
      "zh-Hans": "### 不应该做"
    },
    {
      "en-US": "```cpp\n// Weak interface: unclear ownership, unclear units\ndouble boil(double* temp);\n\n// Non-const global variable\nint g_counter = 0;  // I.2 violation\n```",
      "zh-Hans": "```cpp\n// Weak interface: unclear ownership, unclear units\ndouble boil(double* temp);\n\n// Non-const global variable\nint g_counter = 0;  // I.2 violation\n```"
    },
    {
      "en-US": "## Functions (F.*)",
      "zh-Hans": "## 函数 (F.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **F.1** | Package meaningful operations as carefully named functions |\n| **F.2** | A function should perform a single logical operation |\n| **F.3** | Keep functions short and simple |\n| **F.4** | If a function might be evaluated at compile time, declare it `constexpr` |\n| **F.6** | If your function must not throw, declare it `noexcept` |\n| **F.8** | Prefer pure functions |\n| **F.16** | For \"in\" parameters, pass cheaply-copied types by value and others by `const&` |\n| **F.20** | For \"out\" values, prefer return values to output parameters |\n| **F.21** | To return multiple \"out\" values, prefer returning a struct |\n| **F.43** | Never return a pointer or reference to a local object |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **F.1** | 将有意义的操作打包为精心命名的函数 |\n| **F.2** | 函数应执行单一逻辑操作 |\n| **F.3** | 保持函数简短简单 |\n| **F.4** | 如果函数可能在编译时求值，则将其声明为 `constexpr` |\n| **F.6** | 如果你的函数绝不能抛出异常，则将其声明为 `noexcept` |\n| **F.8** | 优先纯函数 |\n| **F.16** | 对于 \"输入\" 参数，按值传递廉价可复制类型，其他类型通过 `const&` 传递 |\n| **F.20** | 对于 \"输出\" 值，优先返回值而非输出参数 |\n| **F.21** | 要返回多个 \"输出\" 值，优先返回结构体 |\n| **F.43** | 切勿返回指向局部对象的指针或引用 |"
    },
    {
      "en-US": "### Parameter Passing",
      "zh-Hans": "### 参数传递"
    },
    {
      "en-US": "```cpp\n// F.16: Cheap types by value, others by const&\nvoid print(int x);                           // cheap: by value\nvoid analyze(const std::string& data);       // expensive: by const&\nvoid transform(std::string s);               // sink: by value (will move)\n\n// F.20 + F.21: Return values, not output parameters\nstruct ParseResult {\n    std::string token;\n    int position;\n};\n\nParseResult parse(std::string_view input);   // GOOD: return struct\n\n// BAD: output parameters\nvoid parse(std::string_view input,\n           std::string& token, int& pos);    // avoid this\n```",
      "zh-Hans": "```cpp\n// F.16: Cheap types by value, others by const&\nvoid print(int x);                           // cheap: by value\nvoid analyze(const std::string& data);       // expensive: by const&\nvoid transform(std::string s);               // sink: by value (will move)\n\n// F.20 + F.21: Return values, not output parameters\nstruct ParseResult {\n    std::string token;\n    int position;\n};\n\nParseResult parse(std::string_view input);   // GOOD: return struct\n\n// BAD: output parameters\nvoid parse(std::string_view input,\n           std::string& token, int& pos);    // avoid this\n```"
    },
    {
      "en-US": "### Pure Functions and constexpr",
      "zh-Hans": "### 纯函数和 constexpr"
    },
    {
      "en-US": "```cpp\n// F.4 + F.8: Pure, constexpr where possible\nconstexpr int factorial(int n) noexcept {\n    return (n <= 1) ? 1 : n * factorial(n - 1);\n}\n\nstatic_assert(factorial(5) == 120);\n```",
      "zh-Hans": "```cpp\n// F.4 + F.8: Pure, constexpr where possible\nconstexpr int factorial(int n) noexcept {\n    return (n <= 1) ? 1 : n * factorial(n - 1);\n}\n\nstatic_assert(factorial(5) == 120);\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Returning `T&&` from functions (F.45)\n- Using `va_arg` / C-style variadics (F.55)\n- Capturing by reference in lambdas passed to other threads (F.53)\n- Returning `const T` which inhibits move semantics (F.49)",
      "zh-Hans": "* 从函数返回 `T&&` (F.45)\n* 使用 `va_arg` / C 风格可变参数 (F.55)\n* 在传递给其他线程的 lambda 中通过引用捕获 (F.53)\n* 返回 `const T`，这会抑制移动语义 (F.49)"
    },
    {
      "en-US": "## Classes & Class Hierarchies (C.*)",
      "zh-Hans": "## 类与类层次结构 (C.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **C.2** | Use `class` if invariant exists; `struct` if data members vary independently |\n| **C.9** | Minimize exposure of members |\n| **C.20** | If you can avoid defining default operations, do (Rule of Zero) |\n| **C.21** | If you define or `=delete` any copy/move/destructor, handle them all (Rule of Five) |\n| **C.35** | Base class destructor: public virtual or protected non-virtual |\n| **C.41** | A constructor should create a fully initialized object |\n| **C.46** | Declare single-argument constructors `explicit` |\n| **C.67** | A polymorphic class should suppress public copy/move |\n| **C.128** | Virtual functions: specify exactly one of `virtual`, `override`, or `final` |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **C.2** | 如果存在不变式，使用 `class`；如果数据成员独立变化，使用 `struct` |\n| **C.9** | 最小化成员的暴露 |\n| **C.20** | 如果你能避免定义默认操作，就这么做（零规则） |\n| **C.21** | 如果你定义或 `=delete` 任何拷贝/移动/析构函数，则处理所有（五规则） |\n| **C.35** | 基类析构函数：公开虚函数或受保护非虚函数 |\n| **C.41** | 构造函数应创建完全初始化的对象 |\n| **C.46** | 将单参数构造函数声明为 `explicit` |\n| **C.67** | 多态类应禁止公开拷贝/移动 |\n| **C.128** | 虚函数：精确指定 `virtual`、`override` 或 `final` 中的一个 |"
    },
    {
      "en-US": "### Rule of Zero",
      "zh-Hans": "### 零规则"
    },
    {
      "en-US": "```cpp\n// C.20: Let the compiler generate special members\nstruct Employee {\n    std::string name;\n    std::string department;\n    int id;\n    // No destructor, copy/move constructors, or assignment operators needed\n};\n```",
      "zh-Hans": "```cpp\n// C.20: Let the compiler generate special members\nstruct Employee {\n    std::string name;\n    std::string department;\n    int id;\n    // No destructor, copy/move constructors, or assignment operators needed\n};\n```"
    },
    {
      "en-US": "### Rule of Five",
      "zh-Hans": "### 五规则"
    },
    {
      "en-US": "```cpp\n// C.21: If you must manage a resource, define all five\nclass Buffer {\npublic:\n    explicit Buffer(std::size_t size)\n        : data_(std::make_unique<char[]>(size)), size_(size) {}\n\n    ~Buffer() = default;\n\n    Buffer(const Buffer& other)\n        : data_(std::make_unique<char[]>(other.size_)), size_(other.size_) {\n        std::copy_n(other.data_.get(), size_, data_.get());\n    }\n\n    Buffer& operator=(const Buffer& other) {\n        if (this != &other) {\n            auto new_data = std::make_unique<char[]>(other.size_);\n            std::copy_n(other.data_.get(), other.size_, new_data.get());\n            data_ = std::move(new_data);\n            size_ = other.size_;\n        }\n        return *this;\n    }\n\n    Buffer(Buffer&&) noexcept = default;\n    Buffer& operator=(Buffer&&) noexcept = default;\n\nprivate:\n    std::unique_ptr<char[]> data_;\n    std::size_t size_;\n};\n```",
      "zh-Hans": "```cpp\n// C.21: If you must manage a resource, define all five\nclass Buffer {\npublic:\n    explicit Buffer(std::size_t size)\n        : data_(std::make_unique<char[]>(size)), size_(size) {}\n\n    ~Buffer() = default;\n\n    Buffer(const Buffer& other)\n        : data_(std::make_unique<char[]>(other.size_)), size_(other.size_) {\n        std::copy_n(other.data_.get(), size_, data_.get());\n    }\n\n    Buffer& operator=(const Buffer& other) {\n        if (this != &other) {\n            auto new_data = std::make_unique<char[]>(other.size_);\n            std::copy_n(other.data_.get(), other.size_, new_data.get());\n            data_ = std::move(new_data);\n            size_ = other.size_;\n        }\n        return *this;\n    }\n\n    Buffer(Buffer&&) noexcept = default;\n    Buffer& operator=(Buffer&&) noexcept = default;\n\nprivate:\n    std::unique_ptr<char[]> data_;\n    std::size_t size_;\n};\n```"
    },
    {
      "en-US": "### Class Hierarchy",
      "zh-Hans": "### 类层次结构"
    },
    {
      "en-US": "```cpp\n// C.35 + C.128: Virtual destructor, use override\nclass Shape {\npublic:\n    virtual ~Shape() = default;\n    virtual double area() const = 0;  // C.121: pure interface\n};\n\nclass Circle : public Shape {\npublic:\n    explicit Circle(double r) : radius_(r) {}\n    double area() const override { return 3.14159 * radius_ * radius_; }\n\nprivate:\n    double radius_;\n};\n```",
      "zh-Hans": "```cpp\n// C.35 + C.128: Virtual destructor, use override\nclass Shape {\npublic:\n    virtual ~Shape() = default;\n    virtual double area() const = 0;  // C.121: pure interface\n};\n\nclass Circle : public Shape {\npublic:\n    explicit Circle(double r) : radius_(r) {}\n    double area() const override { return 3.14159 * radius_ * radius_; }\n\nprivate:\n    double radius_;\n};\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Calling virtual functions in constructors/destructors (C.82)\n- Using `memset`/`memcpy` on non-trivial types (C.90)\n- Providing different default arguments for virtual function and overrider (C.140)\n- Making data members `const` or references, which suppresses move/copy (C.12)",
      "zh-Hans": "* 在构造函数/析构函数中调用虚函数 (C.82)\n* 在非平凡类型上使用 `memset`/`memcpy` (C.90)\n* 为虚函数和重写函数提供不同的默认参数 (C.140)\n* 将数据成员设为 `const` 或引用，这会抑制移动/拷贝 (C.12)"
    },
    {
      "en-US": "## Resource Management (R.*)",
      "zh-Hans": "## 资源管理 (R.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **R.1** | Manage resources automatically using RAII |\n| **R.3** | A raw pointer (`T*`) is non-owning |\n| **R.5** | Prefer scoped objects; don't heap-allocate unnecessarily |\n| **R.10** | Avoid `malloc()`/`free()` |\n| **R.11** | Avoid calling `new` and `delete` explicitly |\n| **R.20** | Use `unique_ptr` or `shared_ptr` to represent ownership |\n| **R.21** | Prefer `unique_ptr` over `shared_ptr` unless sharing ownership |\n| **R.22** | Use `make_shared()` to make `shared_ptr`s |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **R.1** | 使用 RAII 自动管理资源 |\n| **R.3** | 原始指针 (`T*`) 是非拥有的 |\n| **R.5** | 优先作用域对象；不要不必要地在堆上分配 |\n| **R.10** | 避免 `malloc()`/`free()` |\n| **R.11** | 避免显式调用 `new` 和 `delete` |\n| **R.20** | 使用 `unique_ptr` 或 `shared_ptr` 表示所有权 |\n| **R.21** | 除非共享所有权，否则优先 `unique_ptr` 而非 `shared_ptr` |\n| **R.22** | 使用 `make_shared()` 来创建 `shared_ptr` |"
    },
    {
      "en-US": "### Smart Pointer Usage",
      "zh-Hans": "### 智能指针使用"
    },
    {
      "en-US": "```cpp\n// R.11 + R.20 + R.21: RAII with smart pointers\nauto widget = std::make_unique<Widget>(\"config\");  // unique ownership\nauto cache  = std::make_shared<Cache>(1024);        // shared ownership\n\n// R.3: Raw pointer = non-owning observer\nvoid render(const Widget* w) {  // does NOT own w\n    if (w) w->draw();\n}\n\nrender(widget.get());\n```",
      "zh-Hans": "```cpp\n// R.11 + R.20 + R.21: RAII with smart pointers\nauto widget = std::make_unique<Widget>(\"config\");  // unique ownership\nauto cache  = std::make_shared<Cache>(1024);        // shared ownership\n\n// R.3: Raw pointer = non-owning observer\nvoid render(const Widget* w) {  // does NOT own w\n    if (w) w->draw();\n}\n\nrender(widget.get());\n```"
    },
    {
      "en-US": "### RAII Pattern",
      "zh-Hans": "### RAII 模式"
    },
    {
      "en-US": "```cpp\n// R.1: Resource acquisition is initialization\nclass FileHandle {\npublic:\n    explicit FileHandle(const std::string& path)\n        : handle_(std::fopen(path.c_str(), \"r\")) {\n        if (!handle_) throw std::runtime_error(\"Failed to open: \" + path);\n    }\n\n    ~FileHandle() {\n        if (handle_) std::fclose(handle_);\n    }\n\n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n    FileHandle(FileHandle&& other) noexcept\n        : handle_(std::exchange(other.handle_, nullptr)) {}\n    FileHandle& operator=(FileHandle&& other) noexcept {\n        if (this != &other) {\n            if (handle_) std::fclose(handle_);\n            handle_ = std::exchange(other.handle_, nullptr);\n        }\n        return *this;\n    }\n\nprivate:\n    std::FILE* handle_;\n};\n```",
      "zh-Hans": "```cpp\n// R.1: Resource acquisition is initialization\nclass FileHandle {\npublic:\n    explicit FileHandle(const std::string& path)\n        : handle_(std::fopen(path.c_str(), \"r\")) {\n        if (!handle_) throw std::runtime_error(\"Failed to open: \" + path);\n    }\n\n    ~FileHandle() {\n        if (handle_) std::fclose(handle_);\n    }\n\n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n    FileHandle(FileHandle&& other) noexcept\n        : handle_(std::exchange(other.handle_, nullptr)) {}\n    FileHandle& operator=(FileHandle&& other) noexcept {\n        if (this != &other) {\n            if (handle_) std::fclose(handle_);\n            handle_ = std::exchange(other.handle_, nullptr);\n        }\n        return *this;\n    }\n\nprivate:\n    std::FILE* handle_;\n};\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Naked `new`/`delete` (R.11)\n- `malloc()`/`free()` in C++ code (R.10)\n- Multiple resource allocations in a single expression (R.13 -- exception safety hazard)\n- `shared_ptr` where `unique_ptr` suffices (R.21)",
      "zh-Hans": "* 裸 `new`/`delete` (R.11)\n* C++ 代码中的 `malloc()`/`free()` (R.10)\n* 在单个表达式中进行多次资源分配 (R.13 -- 异常安全风险)\n* 在 `unique_ptr` 足够时使用 `shared_ptr` (R.21)"
    },
    {
      "en-US": "## Expressions & Statements (ES.*)",
      "zh-Hans": "## 表达式与语句 (ES.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **ES.5** | Keep scopes small |\n| **ES.20** | Always initialize an object |\n| **ES.23** | Prefer `{}` initializer syntax |\n| **ES.25** | Declare objects `const` or `constexpr` unless modification is intended |\n| **ES.28** | Use lambdas for complex initialization of `const` variables |\n| **ES.45** | Avoid magic constants; use symbolic constants |\n| **ES.46** | Avoid narrowing/lossy arithmetic conversions |\n| **ES.47** | Use `nullptr` rather than `0` or `NULL` |\n| **ES.48** | Avoid casts |\n| **ES.50** | Don't cast away `const` |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **ES.5** | 保持作用域小 |\n| **ES.20** | 始终初始化对象 |\n| **ES.23** | 优先 `{}` 初始化语法 |\n| **ES.25** | 除非打算修改，否则将对象声明为 `const` 或 `constexpr` |\n| **ES.28** | 使用 lambda 进行 `const` 变量的复杂初始化 |\n| **ES.45** | 避免魔法常量；使用符号常量 |\n| **ES.46** | 避免有损的算术转换 |\n| **ES.47** | 使用 `nullptr` 而非 `0` 或 `NULL` |\n| **ES.48** | 避免强制类型转换 |\n| **ES.50** | 不要丢弃 `const` |"
    },
    {
      "en-US": "### Initialization",
      "zh-Hans": "### 初始化"
    },
    {
      "en-US": "```cpp\n// ES.20 + ES.23 + ES.25: Always initialize, prefer {}, default to const\nconst int max_retries{3};\nconst std::string name{\"widget\"};\nconst std::vector<int> primes{2, 3, 5, 7, 11};\n\n// ES.28: Lambda for complex const initialization\nconst auto config = [&] {\n    Config c;\n    c.timeout = std::chrono::seconds{30};\n    c.retries = max_retries;\n    c.verbose = debug_mode;\n    return c;\n}();\n```",
      "zh-Hans": "```cpp\n// ES.20 + ES.23 + ES.25: Always initialize, prefer {}, default to const\nconst int max_retries{3};\nconst std::string name{\"widget\"};\nconst std::vector<int> primes{2, 3, 5, 7, 11};\n\n// ES.28: Lambda for complex const initialization\nconst auto config = [&] {\n    Config c;\n    c.timeout = std::chrono::seconds{30};\n    c.retries = max_retries;\n    c.verbose = debug_mode;\n    return c;\n}();\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Uninitialized variables (ES.20)\n- Using `0` or `NULL` as pointer (ES.47 -- use `nullptr`)\n- C-style casts (ES.48 -- use `static_cast`, `const_cast`, etc.)\n- Casting away `const` (ES.50)\n- Magic numbers without named constants (ES.45)\n- Mixing signed and unsigned arithmetic (ES.100)\n- Reusing names in nested scopes (ES.12)",
      "zh-Hans": "* 未初始化的变量 (ES.20)\n* 使用 `0` 或 `NULL` 作为指针 (ES.47 -- 使用 `nullptr`)\n* C 风格强制类型转换 (ES.48 -- 使用 `static_cast`、`const_cast` 等)\n* 丢弃 `const` (ES.50)\n* 没有命名常量的魔法数字 (ES.45)\n* 混合有符号和无符号算术 (ES.100)\n* 在嵌套作用域中重用名称 (ES.12)"
    },
    {
      "en-US": "## Error Handling (E.*)",
      "zh-Hans": "## 错误处理 (E.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **E.1** | Develop an error-handling strategy early in a design |\n| **E.2** | Throw an exception to signal that a function can't perform its assigned task |\n| **E.6** | Use RAII to prevent leaks |\n| **E.12** | Use `noexcept` when throwing is impossible or unacceptable |\n| **E.14** | Use purpose-designed user-defined types as exceptions |\n| **E.15** | Throw by value, catch by reference |\n| **E.16** | Destructors, deallocation, and swap must never fail |\n| **E.17** | Don't try to catch every exception in every function |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **E.1** | 在设计早期制定错误处理策略 |\n| **E.2** | 抛出异常以表示函数无法执行其分配的任务 |\n| **E.6** | 使用 RAII 防止泄漏 |\n| **E.12** | 当抛出异常不可能或不可接受时，使用 `noexcept` |\n| **E.14** | 使用专门设计的用户定义类型作为异常 |\n| **E.15** | 按值抛出，按引用捕获 |\n| **E.16** | 析构函数、释放和 swap 绝不能失败 |\n| **E.17** | 不要试图在每个函数中捕获每个异常 |"
    },
    {
      "en-US": "### Exception Hierarchy",
      "zh-Hans": "### 异常层次结构"
    },
    {
      "en-US": "```cpp\n// E.14 + E.15: Custom exception types, throw by value, catch by reference\nclass AppError : public std::runtime_error {\npublic:\n    using std::runtime_error::runtime_error;\n};\n\nclass NetworkError : public AppError {\npublic:\n    NetworkError(const std::string& msg, int code)\n        : AppError(msg), status_code(code) {}\n    int status_code;\n};\n\nvoid fetch_data(const std::string& url) {\n    // E.2: Throw to signal failure\n    throw NetworkError(\"connection refused\", 503);\n}\n\nvoid run() {\n    try {\n        fetch_data(\"https://api.example.com\");\n    } catch (const NetworkError& e) {\n        log_error(e.what(), e.status_code);\n    } catch (const AppError& e) {\n        log_error(e.what());\n    }\n    // E.17: Don't catch everything here -- let unexpected errors propagate\n}\n```",
      "zh-Hans": "```cpp\n// E.14 + E.15: Custom exception types, throw by value, catch by reference\nclass AppError : public std::runtime_error {\npublic:\n    using std::runtime_error::runtime_error;\n};\n\nclass NetworkError : public AppError {\npublic:\n    NetworkError(const std::string& msg, int code)\n        : AppError(msg), status_code(code) {}\n    int status_code;\n};\n\nvoid fetch_data(const std::string& url) {\n    // E.2: Throw to signal failure\n    throw NetworkError(\"connection refused\", 503);\n}\n\nvoid run() {\n    try {\n        fetch_data(\"https://api.example.com\");\n    } catch (const NetworkError& e) {\n        log_error(e.what(), e.status_code);\n    } catch (const AppError& e) {\n        log_error(e.what());\n    }\n    // E.17: Don't catch everything here -- let unexpected errors propagate\n}\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Throwing built-in types like `int` or string literals (E.14)\n- Catching by value (slicing risk) (E.15)\n- Empty catch blocks that silently swallow errors\n- Using exceptions for flow control (E.3)\n- Error handling based on global state like `errno` (E.28)",
      "zh-Hans": "* 抛出内置类型，如 `int` 或字符串字面量 (E.14)\n* 按值捕获（有切片风险） (E.15)\n* 静默吞掉错误的空 catch 块\n* 使用异常进行流程控制 (E.3)\n* 基于全局状态（如 `errno`）的错误处理 (E.28)"
    },
    {
      "en-US": "## Constants & Immutability (Con.*)",
      "zh-Hans": "## 常量与不可变性 (Con.\\*)"
    },
    {
      "en-US": "### All Rules",
      "zh-Hans": "### 所有规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **Con.1** | By default, make objects immutable |\n| **Con.2** | By default, make member functions `const` |\n| **Con.3** | By default, pass pointers and references to `const` |\n| **Con.4** | Use `const` for values that don't change after construction |\n| **Con.5** | Use `constexpr` for values computable at compile time |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **Con.1** | 默认情况下，使对象不可变 |\n| **Con.2** | 默认情况下，使成员函数为 `const` |\n| **Con.3** | 默认情况下，传递指向 `const` 的指针和引用 |\n| **Con.4** | 对构造后不改变的值使用 `const` |\n| **Con.5** | 对可在编译时计算的值使用 `constexpr` |"
    },
    {
      "en-US": "```cpp\n// Con.1 through Con.5: Immutability by default\nclass Sensor {\npublic:\n    explicit Sensor(std::string id) : id_(std::move(id)) {}\n\n    // Con.2: const member functions by default\n    const std::string& id() const { return id_; }\n    double last_reading() const { return reading_; }\n\n    // Only non-const when mutation is required\n    void record(double value) { reading_ = value; }\n\nprivate:\n    const std::string id_;  // Con.4: never changes after construction\n    double reading_{0.0};\n};\n\n// Con.3: Pass by const reference\nvoid display(const Sensor& s) {\n    std::cout << s.id() << \": \" << s.last_reading() << '\\n';\n}\n\n// Con.5: Compile-time constants\nconstexpr double PI = 3.14159265358979;\nconstexpr int MAX_SENSORS = 256;\n```",
      "zh-Hans": "```cpp\n// Con.1 through Con.5: Immutability by default\nclass Sensor {\npublic:\n    explicit Sensor(std::string id) : id_(std::move(id)) {}\n\n    // Con.2: const member functions by default\n    const std::string& id() const { return id_; }\n    double last_reading() const { return reading_; }\n\n    // Only non-const when mutation is required\n    void record(double value) { reading_ = value; }\n\nprivate:\n    const std::string id_;  // Con.4: never changes after construction\n    double reading_{0.0};\n};\n\n// Con.3: Pass by const reference\nvoid display(const Sensor& s) {\n    std::cout << s.id() << \": \" << s.last_reading() << '\\n';\n}\n\n// Con.5: Compile-time constants\nconstexpr double PI = 3.14159265358979;\nconstexpr int MAX_SENSORS = 256;\n```"
    },
    {
      "en-US": "## Concurrency & Parallelism (CP.*)",
      "zh-Hans": "## 并发与并行 (CP.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **CP.2** | Avoid data races |\n| **CP.3** | Minimize explicit sharing of writable data |\n| **CP.4** | Think in terms of tasks, rather than threads |\n| **CP.8** | Don't use `volatile` for synchronization |\n| **CP.20** | Use RAII, never plain `lock()`/`unlock()` |\n| **CP.21** | Use `std::scoped_lock` to acquire multiple mutexes |\n| **CP.22** | Never call unknown code while holding a lock |\n| **CP.42** | Don't wait without a condition |\n| **CP.44** | Remember to name your `lock_guard`s and `unique_lock`s |\n| **CP.100** | Don't use lock-free programming unless you absolutely have to |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **CP.2** | 避免数据竞争 |\n| **CP.3** | 最小化可写数据的显式共享 |\n| **CP.4** | 从任务的角度思考，而非线程 |\n| **CP.8** | 不要使用 `volatile` 进行同步 |\n| **CP.20** | 使用 RAII，切勿使用普通的 `lock()`/`unlock()` |\n| **CP.21** | 使用 `std::scoped_lock` 来获取多个互斥量 |\n| **CP.22** | 持有锁时切勿调用未知代码 |\n| **CP.42** | 不要在没有条件的情况下等待 |\n| **CP.44** | 记得为你的 `lock_guard` 和 `unique_lock` 命名 |\n| **CP.100** | 除非绝对必要，否则不要使用无锁编程 |"
    },
    {
      "en-US": "### Safe Locking",
      "zh-Hans": "### 安全加锁"
    },
    {
      "en-US": "```cpp\n// CP.20 + CP.44: RAII locks, always named\nclass ThreadSafeQueue {\npublic:\n    void push(int value) {\n        std::lock_guard<std::mutex> lock(mutex_);  // CP.44: named!\n        queue_.push(value);\n        cv_.notify_one();\n    }\n\n    int pop() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // CP.42: Always wait with a condition\n        cv_.wait(lock, [this] { return !queue_.empty(); });\n        const int value = queue_.front();\n        queue_.pop();\n        return value;\n    }\n\nprivate:\n    std::mutex mutex_;             // CP.50: mutex with its data\n    std::condition_variable cv_;\n    std::queue<int> queue_;\n};\n```",
      "zh-Hans": "```cpp\n// CP.20 + CP.44: RAII locks, always named\nclass ThreadSafeQueue {\npublic:\n    void push(int value) {\n        std::lock_guard<std::mutex> lock(mutex_);  // CP.44: named!\n        queue_.push(value);\n        cv_.notify_one();\n    }\n\n    int pop() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        // CP.42: Always wait with a condition\n        cv_.wait(lock, [this] { return !queue_.empty(); });\n        const int value = queue_.front();\n        queue_.pop();\n        return value;\n    }\n\nprivate:\n    std::mutex mutex_;             // CP.50: mutex with its data\n    std::condition_variable cv_;\n    std::queue<int> queue_;\n};\n```"
    },
    {
      "en-US": "### Multiple Mutexes",
      "zh-Hans": "### 多个互斥量"
    },
    {
      "en-US": "```cpp\n// CP.21: std::scoped_lock for multiple mutexes (deadlock-free)\nvoid transfer(Account& from, Account& to, double amount) {\n    std::scoped_lock lock(from.mutex_, to.mutex_);\n    from.balance_ -= amount;\n    to.balance_ += amount;\n}\n```",
      "zh-Hans": "```cpp\n// CP.21: std::scoped_lock for multiple mutexes (deadlock-free)\nvoid transfer(Account& from, Account& to, double amount) {\n    std::scoped_lock lock(from.mutex_, to.mutex_);\n    from.balance_ -= amount;\n    to.balance_ += amount;\n}\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- `volatile` for synchronization (CP.8 -- it's for hardware I/O only)\n- Detaching threads (CP.26 -- lifetime management becomes nearly impossible)\n- Unnamed lock guards: `std::lock_guard<std::mutex>(m);` destroys immediately (CP.44)\n- Holding locks while calling callbacks (CP.22 -- deadlock risk)\n- Lock-free programming without deep expertise (CP.100)",
      "zh-Hans": "* 使用 `volatile` 进行同步 (CP.8 -- 它仅用于硬件 I/O)\n* 分离线程 (CP.26 -- 生命周期管理变得几乎不可能)\n* 未命名的锁保护：`std::lock_guard<std::mutex>(m);` 会立即销毁 (CP.44)\n* 调用回调时持有锁 (CP.22 -- 死锁风险)\n* 没有深厚专业知识就进行无锁编程 (CP.100)"
    },
    {
      "en-US": "## Templates & Generic Programming (T.*)",
      "zh-Hans": "## 模板与泛型编程 (T.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **T.1** | Use templates to raise the level of abstraction |\n| **T.2** | Use templates to express algorithms for many argument types |\n| **T.10** | Specify concepts for all template arguments |\n| **T.11** | Use standard concepts whenever possible |\n| **T.13** | Prefer shorthand notation for simple concepts |\n| **T.43** | Prefer `using` over `typedef` |\n| **T.120** | Use template metaprogramming only when you really need to |\n| **T.144** | Don't specialize function templates (overload instead) |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **T.1** | 使用模板来提高抽象级别 |\n| **T.2** | 使用模板为多种参数类型表达算法 |\n| **T.10** | 为所有模板参数指定概念 |\n| **T.11** | 尽可能使用标准概念 |\n| **T.13** | 对于简单概念，优先使用简写符号 |\n| **T.43** | 优先 `using` 而非 `typedef` |\n| **T.120** | 仅在确实需要时使用模板元编程 |\n| **T.144** | 不要特化函数模板（改用重载） |"
    },
    {
      "en-US": "### Concepts (C++20)",
      "zh-Hans": "### 概念 (C++20)"
    },
    {
      "en-US": "```cpp\n#include <concepts>\n\n// T.10 + T.11: Constrain templates with standard concepts\ntemplate<std::integral T>\nT gcd(T a, T b) {\n    while (b != 0) {\n        a = std::exchange(b, a % b);\n    }\n    return a;\n}\n\n// T.13: Shorthand concept syntax\nvoid sort(std::ranges::random_access_range auto& range) {\n    std::ranges::sort(range);\n}\n\n// Custom concept for domain-specific constraints\ntemplate<typename T>\nconcept Serializable = requires(const T& t) {\n    { t.serialize() } -> std::convertible_to<std::string>;\n};\n\ntemplate<Serializable T>\nvoid save(const T& obj, const std::string& path);\n```",
      "zh-Hans": "```cpp\n#include <concepts>\n\n// T.10 + T.11: Constrain templates with standard concepts\ntemplate<std::integral T>\nT gcd(T a, T b) {\n    while (b != 0) {\n        a = std::exchange(b, a % b);\n    }\n    return a;\n}\n\n// T.13: Shorthand concept syntax\nvoid sort(std::ranges::random_access_range auto& range) {\n    std::ranges::sort(range);\n}\n\n// Custom concept for domain-specific constraints\ntemplate<typename T>\nconcept Serializable = requires(const T& t) {\n    { t.serialize() } -> std::convertible_to<std::string>;\n};\n\ntemplate<Serializable T>\nvoid save(const T& obj, const std::string& path);\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反模式"
    },
    {
      "en-US": "- Unconstrained templates in visible namespaces (T.47)\n- Specializing function templates instead of overloading (T.144)\n- Template metaprogramming where `constexpr` suffices (T.120)\n- `typedef` instead of `using` (T.43)",
      "zh-Hans": "* 在可见命名空间中使用无约束模板 (T.47)\n* 特化函数模板而非重载 (T.144)\n* 在 `constexpr` 足够时使用模板元编程 (T.120)\n* 使用 `typedef` 而非 `using` (T.43)"
    },
    {
      "en-US": "## Standard Library (SL.*)",
      "zh-Hans": "## 标准库 (SL.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **SL.1** | Use libraries wherever possible |\n| **SL.2** | Prefer the standard library to other libraries |\n| **SL.con.1** | Prefer `std::array` or `std::vector` over C arrays |\n| **SL.con.2** | Prefer `std::vector` by default |\n| **SL.str.1** | Use `std::string` to own character sequences |\n| **SL.str.2** | Use `std::string_view` to refer to character sequences |\n| **SL.io.50** | Avoid `endl` (use `'\\n'` -- `endl` forces a flush) |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **SL.1** | 尽可能使用库 |\n| **SL.2** | 优先标准库而非其他库 |\n| **SL.con.1** | 优先 `std::array` 或 `std::vector` 而非 C 数组 |\n| **SL.con.2** | 默认情况下优先 `std::vector` |\n| **SL.str.1** | 使用 `std::string` 来拥有字符序列 |\n| **SL.str.2** | 使用 `std::string_view` 来引用字符序列 |\n| **SL.io.50** | 避免 `endl`（使用 `'\\n'` -- `endl` 会强制刷新） |"
    },
    {
      "en-US": "```cpp\n// SL.con.1 + SL.con.2: Prefer vector/array over C arrays\nconst std::array<int, 4> fixed_data{1, 2, 3, 4};\nstd::vector<std::string> dynamic_data;\n\n// SL.str.1 + SL.str.2: string owns, string_view observes\nstd::string build_greeting(std::string_view name) {\n    return \"Hello, \" + std::string(name) + \"!\";\n}\n\n// SL.io.50: Use '\\n' not endl\nstd::cout << \"result: \" << value << '\\n';\n```",
      "zh-Hans": "```cpp\n// SL.con.1 + SL.con.2: Prefer vector/array over C arrays\nconst std::array<int, 4> fixed_data{1, 2, 3, 4};\nstd::vector<std::string> dynamic_data;\n\n// SL.str.1 + SL.str.2: string owns, string_view observes\nstd::string build_greeting(std::string_view name) {\n    return \"Hello, \" + std::string(name) + \"!\";\n}\n\n// SL.io.50: Use '\\n' not endl\nstd::cout << \"result: \" << value << '\\n';\n```"
    },
    {
      "en-US": "## Enumerations (Enum.*)",
      "zh-Hans": "## 枚举 (Enum.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **Enum.1** | Prefer enumerations over macros |\n| **Enum.3** | Prefer `enum class` over plain `enum` |\n| **Enum.5** | Don't use ALL_CAPS for enumerators |\n| **Enum.6** | Avoid unnamed enumerations |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **Enum.1** | 优先枚举而非宏 |\n| **Enum.3** | 优先 `enum class` 而非普通 `enum` |\n| **Enum.5** | 不要对枚举项使用全大写 |\n| **Enum.6** | 避免未命名的枚举 |"
    },
    {
      "en-US": "```cpp\n// Enum.3 + Enum.5: Scoped enum, no ALL_CAPS\nenum class Color { red, green, blue };\nenum class LogLevel { debug, info, warning, error };\n\n// BAD: plain enum leaks names, ALL_CAPS clashes with macros\nenum { RED, GREEN, BLUE };           // Enum.3 + Enum.5 + Enum.6 violation\n#define MAX_SIZE 100                  // Enum.1 violation -- use constexpr\n```",
      "zh-Hans": "```cpp\n// Enum.3 + Enum.5: Scoped enum, no ALL_CAPS\nenum class Color { red, green, blue };\nenum class LogLevel { debug, info, warning, error };\n\n// BAD: plain enum leaks names, ALL_CAPS clashes with macros\nenum { RED, GREEN, BLUE };           // Enum.3 + Enum.5 + Enum.6 violation\n#define MAX_SIZE 100                  // Enum.1 violation -- use constexpr\n```"
    },
    {
      "en-US": "## Source Files & Naming (SF.*, NL.*)",
      "zh-Hans": "## 源文件与命名 (SF.*, NL.*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **SF.1** | Use `.cpp` for code files and `.h` for interface files |\n| **SF.7** | Don't write `using namespace` at global scope in a header |\n| **SF.8** | Use `#include` guards for all `.h` files |\n| **SF.11** | Header files should be self-contained |\n| **NL.5** | Avoid encoding type information in names (no Hungarian notation) |\n| **NL.8** | Use a consistent naming style |\n| **NL.9** | Use ALL_CAPS for macro names only |\n| **NL.10** | Prefer `underscore_style` names |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **SF.1** | 代码文件使用 `.cpp`，接口文件使用 `.h` |\n| **SF.7** | 不要在头文件的全局作用域内写 `using namespace` |\n| **SF.8** | 所有 `.h` 文件都应使用 `#include` 防护 |\n| **SF.11** | 头文件应是自包含的 |\n| **NL.5** | 避免在名称中编码类型信息（不要使用匈牙利命名法） |\n| **NL.8** | 使用一致的命名风格 |\n| **NL.9** | 仅宏名使用 ALL\\_CAPS |\n| **NL.10** | 优先使用 `underscore_style` 命名 |"
    },
    {
      "en-US": "### Header Guard",
      "zh-Hans": "### 头文件防护"
    },
    {
      "en-US": "```cpp\n// SF.8: Include guard (or #pragma once)\n#ifndef PROJECT_MODULE_WIDGET_H\n#define PROJECT_MODULE_WIDGET_H\n\n// SF.11: Self-contained -- include everything this header needs\n#include <string>\n#include <vector>\n\nnamespace project::module {\n\nclass Widget {\npublic:\n    explicit Widget(std::string name);\n    const std::string& name() const;\n\nprivate:\n    std::string name_;\n};\n\n}  // namespace project::module\n\n#endif  // PROJECT_MODULE_WIDGET_H\n```",
      "zh-Hans": "```cpp\n// SF.8: Include guard (or #pragma once)\n#ifndef PROJECT_MODULE_WIDGET_H\n#define PROJECT_MODULE_WIDGET_H\n\n// SF.11: Self-contained -- include everything this header needs\n#include <string>\n#include <vector>\n\nnamespace project::module {\n\nclass Widget {\npublic:\n    explicit Widget(std::string name);\n    const std::string& name() const;\n\nprivate:\n    std::string name_;\n};\n\n}  // namespace project::module\n\n#endif  // PROJECT_MODULE_WIDGET_H\n```"
    },
    {
      "en-US": "### Naming Conventions",
      "zh-Hans": "### 命名约定"
    },
    {
      "en-US": "```cpp\n// NL.8 + NL.10: Consistent underscore_style\nnamespace my_project {\n\nconstexpr int max_buffer_size = 4096;  // NL.9: not ALL_CAPS (it's not a macro)\n\nclass tcp_connection {                 // underscore_style class\npublic:\n    void send_message(std::string_view msg);\n    bool is_connected() const;\n\nprivate:\n    std::string host_;                 // trailing underscore for members\n    int port_;\n};\n\n}  // namespace my_project\n```",
      "zh-Hans": "```cpp\n// NL.8 + NL.10: Consistent underscore_style\nnamespace my_project {\n\nconstexpr int max_buffer_size = 4096;  // NL.9: not ALL_CAPS (it's not a macro)\n\nclass tcp_connection {                 // underscore_style class\npublic:\n    void send_message(std::string_view msg);\n    bool is_connected() const;\n\nprivate:\n    std::string host_;                 // trailing underscore for members\n    int port_;\n};\n\n}  // namespace my_project\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反面模式"
    },
    {
      "en-US": "- `using namespace std;` in a header at global scope (SF.7)\n- Headers that depend on inclusion order (SF.10, SF.11)\n- Hungarian notation like `strName`, `iCount` (NL.5)\n- ALL_CAPS for anything other than macros (NL.9)",
      "zh-Hans": "* 在头文件的全局作用域内使用 `using namespace std;` (SF.7)\n* 依赖包含顺序的头文件 (SF.10, SF.11)\n* 匈牙利命名法，如 `strName`、`iCount` (NL.5)\n* 宏以外的事物使用 ALL\\_CAPS (NL.9)"
    },
    {
      "en-US": "## Performance (Per.*)",
      "zh-Hans": "## 性能 (Per.\\*)"
    },
    {
      "en-US": "### Key Rules",
      "zh-Hans": "### 关键规则"
    },
    {
      "en-US": "| Rule | Summary |\n|------|---------|\n| **Per.1** | Don't optimize without reason |\n| **Per.2** | Don't optimize prematurely |\n| **Per.6** | Don't make claims about performance without measurements |\n| **Per.7** | Design to enable optimization |\n| **Per.10** | Rely on the static type system |\n| **Per.11** | Move computation from run time to compile time |\n| **Per.19** | Access memory predictably |",
      "zh-Hans": "| 规则 | 摘要 |\n|------|---------|\n| **Per.1** | 不要无故优化 |\n| **Per.2** | 不要过早优化 |\n| **Per.6** | 没有测量数据，不要断言性能 |\n| **Per.7** | 设计时应考虑便于优化 |\n| **Per.10** | 依赖静态类型系统 |\n| **Per.11** | 将计算从运行时移至编译时 |\n| **Per.19** | 以可预测的方式访问内存 |"
    },
    {
      "en-US": "### Guidelines",
      "zh-Hans": "### 指导原则"
    },
    {
      "en-US": "```cpp\n// Per.11: Compile-time computation where possible\nconstexpr auto lookup_table = [] {\n    std::array<int, 256> table{};\n    for (int i = 0; i < 256; ++i) {\n        table[i] = i * i;\n    }\n    return table;\n}();\n\n// Per.19: Prefer contiguous data for cache-friendliness\nstd::vector<Point> points;           // GOOD: contiguous\nstd::vector<std::unique_ptr<Point>> indirect_points; // BAD: pointer chasing\n```",
      "zh-Hans": "```cpp\n// Per.11: Compile-time computation where possible\nconstexpr auto lookup_table = [] {\n    std::array<int, 256> table{};\n    for (int i = 0; i < 256; ++i) {\n        table[i] = i * i;\n    }\n    return table;\n}();\n\n// Per.19: Prefer contiguous data for cache-friendliness\nstd::vector<Point> points;           // GOOD: contiguous\nstd::vector<std::unique_ptr<Point>> indirect_points; // BAD: pointer chasing\n```"
    },
    {
      "en-US": "### Anti-Patterns",
      "zh-Hans": "### 反面模式"
    },
    {
      "en-US": "- Optimizing without profiling data (Per.1, Per.6)\n- Choosing \"clever\" low-level code over clear abstractions (Per.4, Per.5)\n- Ignoring data layout and cache behavior (Per.19)",
      "zh-Hans": "* 在没有性能分析数据的情况下进行优化 (Per.1, Per.6)\n* 选择“巧妙”的低级代码而非清晰的抽象 (Per.4, Per.5)\n* 忽略数据布局和缓存行为 (Per.19)"
    },
    {
      "en-US": "## Quick Reference Checklist",
      "zh-Hans": "## 快速参考检查清单"
    },
    {
      "en-US": "Before marking C++ work complete:",
      "zh-Hans": "在标记 C++ 工作完成之前："
    },
    {
      "en-US": "- [ ] No raw `new`/`delete` -- use smart pointers or RAII (R.11)\n- [ ] Objects initialized at declaration (ES.20)\n- [ ] Variables are `const`/`constexpr` by default (Con.1, ES.25)\n- [ ] Member functions are `const` where possible (Con.2)\n- [ ] `enum class` instead of plain `enum` (Enum.3)\n- [ ] `nullptr` instead of `0`/`NULL` (ES.47)\n- [ ] No narrowing conversions (ES.46)\n- [ ] No C-style casts (ES.48)\n- [ ] Single-argument constructors are `explicit` (C.46)\n- [ ] Rule of Zero or Rule of Five applied (C.20, C.21)\n- [ ] Base class destructors are public virtual or protected non-virtual (C.35)\n- [ ] Templates are constrained with concepts (T.10)\n- [ ] No `using namespace` in headers at global scope (SF.7)\n- [ ] Headers have include guards and are self-contained (SF.8, SF.11)\n- [ ] Locks use RAII (`scoped_lock`/`lock_guard`) (CP.20)\n- [ ] Exceptions are custom types, thrown by value, caught by reference (E.14, E.15)\n- [ ] `'\\n'` instead of `std::endl` (SL.io.50)\n- [ ] No magic numbers (ES.45)",
      "zh-Hans": "* \\[ ] 没有裸 `new`/`delete` —— 使用智能指针或 RAII (R.11)\n* \\[ ] 对象在声明时初始化 (ES.20)\n* \\[ ] 变量默认是 `const`/`constexpr` (Con.1, ES.25)\n* \\[ ] 成员函数尽可能设为 `const` (Con.2)\n* \\[ ] 使用 `enum class` 而非普通 `enum` (Enum.3)\n* \\[ ] 使用 `nullptr` 而非 `0`/`NULL` (ES.47)\n* \\[ ] 没有窄化转换 (ES.46)\n* \\[ ] 没有 C 风格转换 (ES.48)\n* \\[ ] 单参数构造函数是 `explicit` (C.46)\n* \\[ ] 应用了零法则或五法则 (C.20, C.21)\n* \\[ ] 基类析构函数是 public virtual 或 protected non-virtual (C.35)\n* \\[ ] 模板使用概念进行约束 (T.10)\n* \\[ ] 头文件全局作用域内没有 `using namespace` (SF.7)\n* \\[ ] 头文件有包含防护且是自包含的 (SF.8, SF.11)\n* \\[ ] 锁使用 RAII (`scoped_lock`/`lock_guard`) (CP.20)\n* \\[ ] 异常是自定义类型，按值抛出，按引用捕获 (E.14, E.15)\n* \\[ ] 使用 `'\\n'` 而非 `std::endl` (SL.io.50)\n* \\[ ] 没有魔数 (ES.45)"
    }
  ]
}