{
  "sourceFile": "the-longform-guide.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "# The Longform Guide to Everything Claude Code",
      "zh-Hans": "# 关于 Claude Code 的完整长篇指南"
    },
    {
      "en-US": "![Header: The Longform Guide to Everything Claude Code](./assets/images/longform/01-header.png)",
      "zh-Hans": "![Header: The Longform Guide to Everything Claude Code](./assets/images/longform/01-header.png)"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "> **Prerequisite**: This guide builds on [The Shorthand Guide to Everything Claude Code](./the-shortform-guide.md). Read that first if you haven't set up skills, hooks, subagents, MCPs, and plugins.",
      "zh-Hans": "> **前提**：本指南建立在 [关于 Claude Code 的简明指南](./the-shortform-guide.md) 之上。如果你还没有设置技能、钩子、子代理、MCP 和插件，请先阅读该指南。"
    },
    {
      "en-US": "![Reference to Shorthand Guide](./assets/images/longform/02-shortform-reference.png)\n*The Shorthand Guide - read it first*",
      "zh-Hans": "![Reference to Shorthand Guide](./assets/images/longform/02-shortform-reference.png)\n*速记指南 - 请先阅读此指南*"
    },
    {
      "en-US": "In the shorthand guide, I covered the foundational setup: skills and commands, hooks, subagents, MCPs, plugins, and the configuration patterns that form the backbone of an effective Claude Code workflow. That was the setup guide and the base infrastructure.",
      "zh-Hans": "在简明指南中，我介绍了基础设置：技能和命令、钩子、子代理、MCP、插件，以及构成有效 Claude Code 工作流骨干的配置模式。那是设置指南和基础架构。"
    },
    {
      "en-US": "This longform guide goes into the techniques that separate productive sessions from wasteful ones. If you haven't read the shorthand guide, go back and set up your configs first. What follows assumes you have skills, agents, hooks, and MCPs already configured and working.",
      "zh-Hans": "这篇长篇指南深入探讨了区分高效会话与浪费会话的技巧。如果你还没有阅读简明指南，请先返回并设置好你的配置。以下内容假定你已经配置好技能、代理、钩子和 MCP，并且它们正在工作。"
    },
    {
      "en-US": "The themes here: token economics, memory persistence, verification patterns, parallelization strategies, and the compound effects of building reusable workflows. These are the patterns I've refined over 10+ months of daily use that make the difference between being plagued by context rot within the first hour, versus maintaining productive sessions for hours.",
      "zh-Hans": "这里的主题是：令牌经济、记忆持久性、验证模式、并行化策略，以及构建可重用工作流的复合效应。这些是我在超过 10 个月的日常使用中提炼出的模式，它们决定了你是在第一个小时内就饱受上下文腐化之苦，还是能够保持数小时的高效会话。"
    },
    {
      "en-US": "Everything covered in the shorthand and longform guides is available on GitHub: `github.com/affaan-m/everything-claude-code`",
      "zh-Hans": "简明指南和长篇指南中涵盖的所有内容都可以在 GitHub 上找到：`github.com/affaan-m/everything-claude-code`"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## Tips and Tricks",
      "zh-Hans": "## 技巧与窍门"
    },
    {
      "en-US": "### Some MCPs are Replaceable and Will Free Up Your Context Window",
      "zh-Hans": "### 有些 MCP 是可替换的，可以释放你的上下文窗口"
    },
    {
      "en-US": "For MCPs such as version control (GitHub), databases (Supabase), deployment (Vercel, Railway) etc. - most of these platforms already have robust CLIs that the MCP is essentially just wrapping. The MCP is a nice wrapper but it comes at a cost.",
      "zh-Hans": "对于诸如版本控制（GitHub）、数据库（Supabase）、部署（Vercel、Railway）等 MCP 来说——这些平台大多已经拥有健壮的 CLI，MCP 本质上只是对其进行包装。MCP 是一个很好的包装器，但它是有代价的。"
    },
    {
      "en-US": "To have the CLI function more like an MCP without actually using the MCP (and the decreased context window that comes with it), consider bundling the functionality into skills and commands. Strip out the tools the MCP exposes that make things easy and turn those into commands.",
      "zh-Hans": "要让 CLI 功能更像 MCP，而不实际使用 MCP（以及随之而来的减少的上下文窗口），可以考虑将功能打包成技能和命令。提取出 MCP 暴露的、使事情变得容易的工具，并将它们转化为命令。"
    },
    {
      "en-US": "Example: instead of having the GitHub MCP loaded at all times, create a `/gh-pr` command that wraps `gh pr create` with your preferred options. Instead of the Supabase MCP eating context, create skills that use the Supabase CLI directly.",
      "zh-Hans": "示例：与其始终加载 GitHub MCP，不如创建一个包装了 `gh pr create` 并带有你偏好选项的 `/gh-pr` 命令。与其让 Supabase MCP 消耗上下文，不如创建直接使用 Supabase CLI 的技能。"
    },
    {
      "en-US": "With lazy loading, the context window issue is mostly solved. But token usage and cost is not solved in the same way. The CLI + skills approach is still a token optimization method.",
      "zh-Hans": "有了延迟加载，上下文窗口问题基本解决了。但令牌使用和成本问题并未以同样的方式解决。CLI + 技能的方法仍然是一种令牌优化方法。"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## IMPORTANT STUFF",
      "zh-Hans": "## 重要事项"
    },
    {
      "en-US": "### Context and Memory Management",
      "zh-Hans": "### 上下文与记忆管理"
    },
    {
      "en-US": "For sharing memory across sessions, a skill or command that summarizes and checks in on progress then saves to a `.tmp` file in your `.claude` folder and appends to it until the end of your session is the best bet. The next day it can use that as context and pick up where you left off, create a new file for each session so you don't pollute old context into new work.",
      "zh-Hans": "要在会话间共享记忆，最好的方法是使用一个技能或命令来总结和检查进度，然后保存到 `.claude` 文件夹中的一个 `.tmp` 文件中，并在会话结束前不断追加内容。第二天，它可以将其用作上下文，并从中断处继续。为每个会话创建一个新文件，这样你就不会将旧的上下文污染到新的工作中。"
    },
    {
      "en-US": "![Session Storage File Tree](./assets/images/longform/03-session-storage.png)\n*Example of session storage -> https://github.com/affaan-m/everything-claude-code/tree/main/examples/sessions*",
      "zh-Hans": "![Session Storage File Tree](./assets/images/longform/03-session-storage.png)\n*会话存储示例 -> https://github.com/affaan-m/everything-claude-code/tree/main/examples/sessions*"
    },
    {
      "en-US": "Claude creates a file summarizing current state. Review it, ask for edits if needed, then start fresh. For the new conversation, just provide the file path. Particularly useful when you're hitting context limits and need to continue complex work. These files should contain:",
      "zh-Hans": "Claude 创建一个总结当前状态的文件。审阅它，如果需要则要求编辑，然后重新开始。对于新的对话，只需提供文件路径。当你达到上下文限制并需要继续复杂工作时，这尤其有用。这些文件应包含："
    },
    {
      "en-US": "- What approaches worked (verifiably with evidence)\n- Which approaches were attempted but did not work\n- Which approaches have not been attempted and what's left to do",
      "zh-Hans": "* 哪些方法有效（有证据可验证）\n* 哪些方法尝试过但无效\n* 哪些方法尚未尝试，以及剩下什么需要做"
    },
    {
      "en-US": "**Clearing Context Strategically:**",
      "zh-Hans": "**策略性地清除上下文：**"
    },
    {
      "en-US": "Once you have your plan set and context cleared (default option in plan mode in Claude Code now), you can work from the plan. This is useful when you've accumulated a lot of exploration context that's no longer relevant to execution. For strategic compacting, disable auto compact. Manually compact at logical intervals or create a skill that does so for you.",
      "zh-Hans": "一旦你制定了计划并清除了上下文（Claude Code 中计划模式的默认选项），你就可以根据计划工作。当你积累了大量与执行不再相关的探索性上下文时，这很有用。对于策略性压缩，请禁用自动压缩。在逻辑间隔手动压缩，或创建一个为你执行此操作的技能。"
    },
    {
      "en-US": "**Advanced: Dynamic System Prompt Injection**",
      "zh-Hans": "**高级：动态系统提示注入**"
    },
    {
      "en-US": "One pattern I picked up: instead of solely putting everything in CLAUDE.md (user scope) or `.claude/rules/` (project scope) which loads every session, use CLI flags to inject context dynamically.",
      "zh-Hans": "我学到的一个模式是：与其将所有内容都放在 CLAUDE.md（用户作用域）或 `.claude/rules/`（项目作用域）中，让它们每次会话都加载，不如使用 CLI 标志动态注入上下文。"
    },
    {
      "en-US": "```bash\nclaude --system-prompt \"$(cat memory.md)\"\n```",
      "zh-Hans": "```bash\nclaude --system-prompt \"$(cat memory.md)\"\n```"
    },
    {
      "en-US": "This lets you be more surgical about what context loads when. System prompt content has higher authority than user messages, which have higher authority than tool results.",
      "zh-Hans": "这让你可以更精确地控制何时加载哪些上下文。系统提示内容比用户消息具有更高的权威性，而用户消息又比工具结果具有更高的权威性。"
    },
    {
      "en-US": "**Practical setup:**",
      "zh-Hans": "**实际设置：**"
    },
    {
      "en-US": "```bash\n# Daily development\nalias claude-dev='claude --system-prompt \"$(cat ~/.claude/contexts/dev.md)\"'\n\n# PR review mode\nalias claude-review='claude --system-prompt \"$(cat ~/.claude/contexts/review.md)\"'\n\n# Research/exploration mode\nalias claude-research='claude --system-prompt \"$(cat ~/.claude/contexts/research.md)\"'\n```",
      "zh-Hans": "```bash\n# Daily development\nalias claude-dev='claude --system-prompt \"$(cat ~/.claude/contexts/dev.md)\"'\n\n# PR review mode\nalias claude-review='claude --system-prompt \"$(cat ~/.claude/contexts/review.md)\"'\n\n# Research/exploration mode\nalias claude-research='claude --system-prompt \"$(cat ~/.claude/contexts/research.md)\"'\n```"
    },
    {
      "en-US": "**Advanced: Memory Persistence Hooks**",
      "zh-Hans": "**高级：记忆持久化钩子**"
    },
    {
      "en-US": "There are hooks most people don't know about that help with memory:",
      "zh-Hans": "有一些大多数人不知道的钩子，有助于记忆管理："
    },
    {
      "en-US": "- **PreCompact Hook**: Before context compaction happens, save important state to a file\n- **Stop Hook (Session End)**: On session end, persist learnings to a file\n- **SessionStart Hook**: On new session, load previous context automatically",
      "zh-Hans": "* **PreCompact 钩子**：在上下文压缩发生之前，将重要状态保存到文件\n* **Stop 钩子（会话结束）**：在会话结束时，将学习成果持久化到文件\n* **SessionStart 钩子**：在新会话开始时，自动加载之前的上下文"
    },
    {
      "en-US": "I've built these hooks and they're in the repo at `github.com/affaan-m/everything-claude-code/tree/main/hooks/memory-persistence`",
      "zh-Hans": "我已经构建了这些钩子，它们位于仓库的 `github.com/affaan-m/everything-claude-code/tree/main/hooks/memory-persistence`"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "### Continuous Learning / Memory",
      "zh-Hans": "### 持续学习 / 记忆"
    },
    {
      "en-US": "If you've had to repeat a prompt multiple times and Claude ran into the same problem or gave you a response you've heard before - those patterns must be appended to skills.",
      "zh-Hans": "如果你不得不多次重复一个提示，并且 Claude 遇到了同样的问题或给出了你以前听过的回答——这些模式必须被附加到技能中。"
    },
    {
      "en-US": "**The Problem:** Wasted tokens, wasted context, wasted time.",
      "zh-Hans": "**问题：** 浪费令牌，浪费上下文，浪费时间。"
    },
    {
      "en-US": "**The Solution:** When Claude Code discovers something that isn't trivial - a debugging technique, a workaround, some project-specific pattern - it saves that knowledge as a new skill. Next time a similar problem comes up, the skill gets loaded automatically.",
      "zh-Hans": "**解决方案：** 当 Claude Code 发现一些不平凡的事情时——调试技巧、变通方法、某些项目特定的模式——它会将该知识保存为一个新技能。下次出现类似问题时，该技能会自动加载。"
    },
    {
      "en-US": "I've built a continuous learning skill that does this: `github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning`",
      "zh-Hans": "我构建了一个实现此功能的持续学习技能：`github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning`"
    },
    {
      "en-US": "**Why Stop Hook (Not UserPromptSubmit):**",
      "zh-Hans": "**为什么用 Stop 钩子（而不是 UserPromptSubmit）：**"
    },
    {
      "en-US": "The key design decision is using a **Stop hook** instead of UserPromptSubmit. UserPromptSubmit runs on every single message - adds latency to every prompt. Stop runs once at session end - lightweight, doesn't slow you down during the session.",
      "zh-Hans": "关键的设计决策是使用 **Stop 钩子** 而不是 UserPromptSubmit。UserPromptSubmit 在每个消息上运行——给每个提示增加延迟。Stop 在会话结束时只运行一次——轻量级，不会在会话期间拖慢你的速度。"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "### Token Optimization",
      "zh-Hans": "### 令牌优化"
    },
    {
      "en-US": "**Primary Strategy: Subagent Architecture**",
      "zh-Hans": "**主要策略：子代理架构**"
    },
    {
      "en-US": "Optimize the tools you use and subagent architecture designed to delegate the cheapest possible model that is sufficient for the task.",
      "zh-Hans": "优化你使用的工具和子代理架构，旨在将任务委托给最便宜且足以胜任的模型。"
    },
    {
      "en-US": "**Model Selection Quick Reference:**",
      "zh-Hans": "**模型选择快速参考：**"
    },
    {
      "en-US": "![Model Selection Table](./assets/images/longform/04-model-selection.png)\n*Hypothetical setup of subagents on various common tasks and reasoning behind the choices*",
      "zh-Hans": "![Model Selection Table](./assets/images/longform/04-model-selection.png)\n*针对各种常见任务的子代理假设设置及选择背后的推理*"
    },
    {
      "en-US": "| Task Type                 | Model  | Why                                        |\n| ------------------------- | ------ | ------------------------------------------ |\n| Exploration/search        | Haiku  | Fast, cheap, good enough for finding files |\n| Simple edits              | Haiku  | Single-file changes, clear instructions    |\n| Multi-file implementation | Sonnet | Best balance for coding                    |\n| Complex architecture      | Opus   | Deep reasoning needed                      |\n| PR reviews                | Sonnet | Understands context, catches nuance        |\n| Security analysis         | Opus   | Can't afford to miss vulnerabilities       |\n| Writing docs              | Haiku  | Structure is simple                        |\n| Debugging complex bugs    | Opus   | Needs to hold entire system in mind        |",
      "zh-Hans": "| 任务类型                 | 模型   | 原因                                       |\n| ------------------------- | ------ | ------------------------------------------ |\n| 探索/搜索                | Haiku  | 快速、便宜，足以用于查找文件               |\n| 简单编辑                 | Haiku  | 单文件更改，指令清晰                       |\n| 多文件实现               | Sonnet | 编码的最佳平衡                             |\n| 复杂架构                 | Opus   | 需要深度推理                               |\n| PR 审查                  | Sonnet | 理解上下文，捕捉细微差别                   |\n| 安全分析                 | Opus   | 不能错过漏洞                               |\n| 编写文档                 | Haiku  | 结构简单                                   |\n| 调试复杂错误             | Opus   | 需要将整个系统记在脑中                     |"
    },
    {
      "en-US": "Default to Sonnet for 90% of coding tasks. Upgrade to Opus when first attempt failed, task spans 5+ files, architectural decisions, or security-critical code.",
      "zh-Hans": "对于 90% 的编码任务，默认使用 Sonnet。当第一次尝试失败、任务涉及 5 个以上文件、架构决策或安全关键代码时，升级到 Opus。"
    },
    {
      "en-US": "**Pricing Reference:**",
      "zh-Hans": "**定价参考：**"
    },
    {
      "en-US": "![Claude Model Pricing](./assets/images/longform/05-pricing-table.png)\n*Source: https://platform.claude.com/docs/en/about-claude/pricing*",
      "zh-Hans": "![Claude Model Pricing](./assets/images/longform/05-pricing-table.png)\n*来源：https://platform.claude.com/docs/en/about-claude/pricing*"
    },
    {
      "en-US": "**Tool-Specific Optimizations:**",
      "zh-Hans": "**工具特定优化：**"
    },
    {
      "en-US": "Replace grep with mgrep - ~50% token reduction on average compared to traditional grep or ripgrep:",
      "zh-Hans": "用 mgrep 替换 grep——与传统 grep 或 ripgrep 相比，平均减少约 50% 的令牌："
    },
    {
      "en-US": "![mgrep Benchmark](./assets/images/longform/06-mgrep-benchmark.png)\n*In our 50-task benchmark, mgrep + Claude Code used ~2x fewer tokens than grep-based workflows at similar or better judged quality. Source: https://github.com/mixedbread-ai/mgrep*",
      "zh-Hans": "![mgrep Benchmark](./assets/images/longform/06-mgrep-benchmark.png)\n*在我们的 50 项任务基准测试中，mgrep + Claude Code 使用的 token 数量比基于 grep 的工作流少约 2 倍，且判断质量相似或更好。来源：https://github.com/mixedbread-ai/mgrep*"
    },
    {
      "en-US": "**Modular Codebase Benefits:**",
      "zh-Hans": "**模块化代码库的好处：**"
    },
    {
      "en-US": "Having a more modular codebase with main files being in the hundreds of lines instead of thousands of lines helps both in token optimization costs and getting a task done right on the first try.",
      "zh-Hans": "拥有一个更模块化的代码库，主文件只有数百行而不是数千行，这有助于降低令牌优化成本，并确保任务在第一次尝试时就正确完成。"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "### Verification Loops and Evals",
      "zh-Hans": "### 验证循环与评估"
    },
    {
      "en-US": "**Benchmarking Workflow:**",
      "zh-Hans": "**基准测试工作流：**"
    },
    {
      "en-US": "Compare asking for the same thing with and without a skill and checking the output difference:",
      "zh-Hans": "比较在有和没有技能的情况下询问同一件事，并检查输出差异："
    },
    {
      "en-US": "Fork the conversation, initiate a new worktree in one of them without the skill, pull up a diff at the end, see what was logged.",
      "zh-Hans": "分叉对话，在其中之一的对话中初始化一个新的工作树但不使用该技能，最后拉取差异，查看记录了什么。"
    },
    {
      "en-US": "**Eval Pattern Types:**",
      "zh-Hans": "**评估模式类型：**"
    },
    {
      "en-US": "- **Checkpoint-Based Evals**: Set explicit checkpoints, verify against defined criteria, fix before proceeding\n- **Continuous Evals**: Run every N minutes or after major changes, full test suite + lint",
      "zh-Hans": "* **基于检查点的评估**：设置明确的检查点，根据定义的标准进行验证，在继续之前修复\n* **持续评估**：每 N 分钟或在重大更改后运行，完整的测试套件 + 代码检查"
    },
    {
      "en-US": "**Key Metrics:**",
      "zh-Hans": "**关键指标：**"
    },
    {
      "en-US": "```\npass@k: At least ONE of k attempts succeeds\n        k=1: 70%  k=3: 91%  k=5: 97%\n\npass^k: ALL k attempts must succeed\n        k=1: 70%  k=3: 34%  k=5: 17%\n```",
      "zh-Hans": "```\npass@k: At least ONE of k attempts succeeds\n        k=1: 70%  k=3: 91%  k=5: 97%\n\npass^k: ALL k attempts must succeed\n        k=1: 70%  k=3: 34%  k=5: 17%\n```"
    },
    {
      "en-US": "Use **pass@k** when you just need it to work. Use **pass^k** when consistency is essential.",
      "zh-Hans": "当你只需要它能工作时，使用 **pass@k**。当一致性至关重要时，使用 **pass^k**。"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## PARALLELIZATION",
      "zh-Hans": "## 并行化"
    },
    {
      "en-US": "When forking conversations in a multi-Claude terminal setup, make sure the scope is well-defined for the actions in the fork and the original conversation. Aim for minimal overlap when it comes to code changes.",
      "zh-Hans": "在多 Claude 终端设置中分叉对话时，请确保分叉中的操作和原始对话的范围定义明确。在代码更改方面，力求最小化重叠。"
    },
    {
      "en-US": "**My Preferred Pattern:**",
      "zh-Hans": "**我偏好的模式：**"
    },
    {
      "en-US": "Main chat for code changes, forks for questions about the codebase and its current state, or research on external services.",
      "zh-Hans": "主聊天用于代码更改，分叉用于询问有关代码库及其当前状态的问题，或研究外部服务。"
    },
    {
      "en-US": "**On Arbitrary Terminal Counts:**",
      "zh-Hans": "**关于任意终端数量：**"
    },
    {
      "en-US": "![Boris on Parallel Terminals](./assets/images/longform/07-boris-parallel.png)\n*Boris (Anthropic) on running multiple Claude instances*",
      "zh-Hans": "![Boris on Parallel Terminals](./assets/images/longform/07-boris-parallel.png)\n*Boris (Anthropic) 关于运行多个 Claude 实例的说明*"
    },
    {
      "en-US": "Boris has tips on parallelization. He's suggested things like running 5 Claude instances locally and 5 upstream. I advise against setting arbitrary terminal amounts. The addition of a terminal should be out of true necessity.",
      "zh-Hans": "Boris 有关于并行化的建议。他曾建议在本地运行 5 个 Claude 实例，在上游运行 5 个。我建议不要设置任意的终端数量。增加终端应该是出于真正的必要性。"
    },
    {
      "en-US": "Your goal should be: **how much can you get done with the minimum viable amount of parallelization.**",
      "zh-Hans": "你的目标应该是：**用最小可行的并行化程度，你能完成多少工作。**"
    },
    {
      "en-US": "**Git Worktrees for Parallel Instances:**",
      "zh-Hans": "**用于并行实例的 Git Worktrees：**"
    },
    {
      "en-US": "```bash\n# Create worktrees for parallel work\ngit worktree add ../project-feature-a feature-a\ngit worktree add ../project-feature-b feature-b\ngit worktree add ../project-refactor refactor-branch\n\n# Each worktree gets its own Claude instance\ncd ../project-feature-a && claude\n```",
      "zh-Hans": "```bash\n# Create worktrees for parallel work\ngit worktree add ../project-feature-a feature-a\ngit worktree add ../project-feature-b feature-b\ngit worktree add ../project-refactor refactor-branch\n\n# Each worktree gets its own Claude instance\ncd ../project-feature-a && claude\n```"
    },
    {
      "en-US": "IF you are to begin scaling your instances AND you have multiple instances of Claude working on code that overlaps with one another, it's imperative you use git worktrees and have a very well-defined plan for each. Use `/rename <name here>` to name all your chats.",
      "zh-Hans": "**如果** 你要开始扩展实例数量 **并且** 你有多个 Claude 实例在处理相互重叠的代码，那么你必须使用 git worktrees，并为每个实例制定非常明确的计划。使用 `/rename <name here>` 来命名你所有的聊天。"
    },
    {
      "en-US": "![Two Terminal Setup](./assets/images/longform/08-two-terminals.png)\n*Starting Setup: Left Terminal for Coding, Right Terminal for Questions - use /rename and /fork*",
      "zh-Hans": "![Two Terminal Setup](./assets/images/longform/08-two-terminals.png)\n*初始设置：左侧终端用于编码，右侧终端用于提问 - 使用 /rename 和 /fork 命令*"
    },
    {
      "en-US": "**The Cascade Method:**",
      "zh-Hans": "**级联方法：**"
    },
    {
      "en-US": "When running multiple Claude Code instances, organize with a \"cascade\" pattern:",
      "zh-Hans": "当运行多个 Claude Code 实例时，使用“级联”模式进行组织："
    },
    {
      "en-US": "- Open new tasks in new tabs to the right\n- Sweep left to right, oldest to newest\n- Focus on at most 3-4 tasks at a time",
      "zh-Hans": "* 在右侧的新标签页中打开新任务\n* 从左到右、从旧到新进行扫描\n* 一次最多专注于 3-4 个任务"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## GROUNDWORK",
      "zh-Hans": "## 基础工作"
    },
    {
      "en-US": "**The Two-Instance Kickoff Pattern:**",
      "zh-Hans": "**双实例启动模式：**"
    },
    {
      "en-US": "For my own workflow management, I like to start an empty repo with 2 open Claude instances.",
      "zh-Hans": "对于我自己的工作流管理，我喜欢从一个空仓库开始，打开 2 个 Claude 实例。"
    },
    {
      "en-US": "**Instance 1: Scaffolding Agent**",
      "zh-Hans": "**实例 1：脚手架代理**"
    },
    {
      "en-US": "- Lays down the scaffold and groundwork\n- Creates project structure\n- Sets up configs (CLAUDE.md, rules, agents)",
      "zh-Hans": "* 搭建脚手架和基础工作\n* 创建项目结构\n* 设置配置（CLAUDE.md、规则、代理）"
    },
    {
      "en-US": "**Instance 2: Deep Research Agent**",
      "zh-Hans": "**实例 2：深度研究代理**"
    },
    {
      "en-US": "- Connects to all your services, web search\n- Creates the detailed PRD\n- Creates architecture mermaid diagrams\n- Compiles the references with actual documentation clips",
      "zh-Hans": "* 连接到你的所有服务，进行网络搜索\n* 创建详细的 PRD\n* 创建架构 Mermaid 图\n* 编译包含实际文档片段的参考资料"
    },
    {
      "en-US": "**llms.txt Pattern:**",
      "zh-Hans": "**llms.txt 模式：**"
    },
    {
      "en-US": "If available, you can find an `llms.txt` on many documentation references by doing `/llms.txt` on them once you reach their docs page. This gives you a clean, LLM-optimized version of the documentation.",
      "zh-Hans": "如果可用，你可以通过在你到达它们的文档页面后执行 `/llms.txt` 来在许多文档参考资料上找到一个 `llms.txt`。这会给你一个干净的、针对 LLM 优化的文档版本。"
    },
    {
      "en-US": "**Philosophy: Build Reusable Patterns**",
      "zh-Hans": "**理念：构建可重用的模式**"
    },
    {
      "en-US": "From @omarsar0: \"Early on, I spent time building reusable workflows/patterns. Tedious to build, but this had a wild compounding effect as models and agent harnesses improved.\"",
      "zh-Hans": "来自 @omarsar0：\"早期，我花时间构建可重用的工作流/模式。构建过程很繁琐，但随着模型和代理框架的改进，这产生了惊人的复合效应。\""
    },
    {
      "en-US": "**What to invest in:**",
      "zh-Hans": "**应该投资于：**"
    },
    {
      "en-US": "- Subagents\n- Skills\n- Commands\n- Planning patterns\n- MCP tools\n- Context engineering patterns",
      "zh-Hans": "* 子代理\n* 技能\n* 命令\n* 规划模式\n* MCP 工具\n* 上下文工程模式"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## Best Practices for Agents & Sub-Agents",
      "zh-Hans": "## 代理与子代理的最佳实践"
    },
    {
      "en-US": "**The Sub-Agent Context Problem:**",
      "zh-Hans": "**子代理上下文问题：**"
    },
    {
      "en-US": "Sub-agents exist to save context by returning summaries instead of dumping everything. But the orchestrator has semantic context the sub-agent lacks. The sub-agent only knows the literal query, not the PURPOSE behind the request.",
      "zh-Hans": "子代理的存在是为了通过返回摘要而不是转储所有内容来节省上下文。但编排器拥有子代理所缺乏的语义上下文。子代理只知道字面查询，不知道请求背后的 **目的**。"
    },
    {
      "en-US": "**Iterative Retrieval Pattern:**",
      "zh-Hans": "**迭代检索模式：**"
    },
    {
      "en-US": "1. Orchestrator evaluates every sub-agent return\n2. Ask follow-up questions before accepting it\n3. Sub-agent goes back to source, gets answers, returns\n4. Loop until sufficient (max 3 cycles)",
      "zh-Hans": "1. 编排器评估每个子代理的返回\n2. 在接受之前询问后续问题\n3. 子代理返回源，获取答案，返回\n4. 循环直到足够（最多 3 个周期）"
    },
    {
      "en-US": "**Key:** Pass objective context, not just the query.",
      "zh-Hans": "**关键：** 传递目标上下文，而不仅仅是查询。"
    },
    {
      "en-US": "**Orchestrator with Sequential Phases:**",
      "zh-Hans": "**具有顺序阶段的编排器：**"
    },
    {
      "en-US": "```markdown\nPhase 1: RESEARCH (use Explore agent) → research-summary.md\nPhase 2: PLAN (use planner agent) → plan.md\nPhase 3: IMPLEMENT (use tdd-guide agent) → code changes\nPhase 4: REVIEW (use code-reviewer agent) → review-comments.md\nPhase 5: VERIFY (use build-error-resolver if needed) → done or loop back\n```",
      "zh-Hans": "```markdown\n第一阶段：研究（使用探索智能体）→ research-summary.md\n第二阶段：规划（使用规划智能体）→ plan.md\n第三阶段：实施（使用测试驱动开发指南智能体）→ 代码变更\n第四阶段：审查（使用代码审查智能体）→ review-comments.md\n第五阶段：验证（如需则使用构建错误解决器）→ 完成或循环返回\n\n```"
    },
    {
      "en-US": "**Key rules:**",
      "zh-Hans": "**关键规则：**"
    },
    {
      "en-US": "1. Each agent gets ONE clear input and produces ONE clear output\n2. Outputs become inputs for next phase\n3. Never skip phases\n4. Use `/clear` between agents\n5. Store intermediate outputs in files",
      "zh-Hans": "1. 每个智能体获得一个清晰的输入并产生一个清晰的输出\n2. 输出成为下一阶段的输入\n3. 永远不要跳过阶段\n4. 在智能体之间使用 `/clear`\n5. 将中间输出存储在文件中"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## FUN STUFF / NOT CRITICAL JUST FUN TIPS",
      "zh-Hans": "## 有趣的东西 / 非关键，仅供娱乐的小贴士"
    },
    {
      "en-US": "### Custom Status Line",
      "zh-Hans": "### 自定义状态栏"
    },
    {
      "en-US": "You can set it using `/statusline` - then Claude will say you don't have one but can set it up for you and ask what you want in it.",
      "zh-Hans": "你可以使用 `/statusline` 来设置它 - 然后 Claude 会说你没有状态栏，但可以为你设置，并询问你想要在里面放什么。"
    },
    {
      "en-US": "See also: https://github.com/sirmalloc/ccstatusline",
      "zh-Hans": "另请参阅：https://github.com/sirmalloc/ccstatusline"
    },
    {
      "en-US": "### Voice Transcription",
      "zh-Hans": "### 语音转录"
    },
    {
      "en-US": "Talk to Claude Code with your voice. Faster than typing for many people.",
      "zh-Hans": "用你的声音与 Claude Code 对话。对很多人来说比打字更快。"
    },
    {
      "en-US": "- superwhisper, MacWhisper on Mac\n- Even with transcription mistakes, Claude understands intent",
      "zh-Hans": "* Mac 上的 superwhisper、MacWhisper\n* 即使转录有误，Claude 也能理解意图"
    },
    {
      "en-US": "### Terminal Aliases",
      "zh-Hans": "### 终端别名"
    },
    {
      "en-US": "```bash\nalias c='claude'\nalias gb='github'\nalias co='code'\nalias q='cd ~/Desktop/projects'\n```",
      "zh-Hans": "```bash\nalias c='claude'\nalias gb='github'\nalias co='code'\nalias q='cd ~/Desktop/projects'\n```"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## Milestone",
      "zh-Hans": "## 里程碑"
    },
    {
      "en-US": "![25k+ GitHub Stars](./assets/images/longform/09-25k-stars.png)\n*25,000+ GitHub stars in under a week*",
      "zh-Hans": "![25k+ GitHub Stars](./assets/images/longform/09-25k-stars.png)\n*一周内获得 25,000+ GitHub stars*"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## Resources",
      "zh-Hans": "## 资源"
    },
    {
      "en-US": "**Agent Orchestration:**",
      "zh-Hans": "**智能体编排：**"
    },
    {
      "en-US": "- https://github.com/ruvnet/claude-flow - Enterprise orchestration platform with 54+ specialized agents",
      "zh-Hans": "* https://github.com/ruvnet/claude-flow - 拥有 54+ 个专业智能体的企业级编排平台"
    },
    {
      "en-US": "**Self-Improving Memory:**",
      "zh-Hans": "**自我改进记忆：**"
    },
    {
      "en-US": "- https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning\n- rlancemartin.github.io/2025/12/01/claude_diary/ - Session reflection pattern",
      "zh-Hans": "* https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning\n* rlancemartin.github.io/2025/12/01/claude\\_diary/ - 会话反思模式"
    },
    {
      "en-US": "**System Prompts Reference:**",
      "zh-Hans": "**系统提示词参考：**"
    },
    {
      "en-US": "- https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools - Collection of system prompts (110k stars)",
      "zh-Hans": "* https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools - 系统提示词集合 (110k stars)"
    },
    {
      "en-US": "**Official:**",
      "zh-Hans": "**官方：**"
    },
    {
      "en-US": "- Anthropic Academy: anthropic.skilljar.com",
      "zh-Hans": "* Anthropic Academy: anthropic.skilljar.com"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "## References",
      "zh-Hans": "## 参考资料"
    },
    {
      "en-US": "- [Anthropic: Demystifying evals for AI agents](https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents)\n- [YK: 32 Claude Code Tips](https://agenticcoding.substack.com/p/32-claude-code-tips-from-basics-to)\n- [RLanceMartin: Session Reflection Pattern](https://rlancemartin.github.io/2025/12/01/claude_diary/)\n- @PerceptualPeak: Sub-Agent Context Negotiation\n- @menhguin: Agent Abstractions Tierlist\n- @omarsar0: Compound Effects Philosophy",
      "zh-Hans": "* [Anthropic: 解密 AI 智能体的评估](https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents)\n* [YK: 32 个 Claude Code 技巧](https://agenticcoding.substack.com/p/32-claude-code-tips-from-basics-to)\n* [RLanceMartin: 会话反思模式](https://rlancemartin.github.io/2025/12/01/claude_diary/)\n* @PerceptualPeak: 子智能体上下文协商\n* @menhguin: 智能体抽象层分级\n* @omarsar0: 复合效应哲学"
    },
    {
      "en-US": "---",
      "zh-Hans": "***"
    },
    {
      "en-US": "*Everything covered in both guides is available on GitHub at [everything-claude-code](https://github.com/affaan-m/everything-claude-code)*",
      "zh-Hans": "*两份指南中涵盖的所有内容都可以在 GitHub 上的 [everything-claude-code](https://github.com/affaan-m/everything-claude-code) 找到*"
    }
  ]
}