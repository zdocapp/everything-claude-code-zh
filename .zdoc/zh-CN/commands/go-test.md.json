{
  "sourceFile": "commands/go-test.md",
  "sourceLanguage": "en-US",
  "entries": [
    {
      "en-US": "---\ndescription: Enforce TDD workflow for Go. Write table-driven tests first, then implement. Verify 80%+ coverage with go test -cover.\n---",
      "zh-Hans": "---\ndescription: 强制执行 Go 的 TDD 工作流程。先编写表格驱动测试，然后实现。使用 go test -cover 验证 80%+ 覆盖率。\n---"
    },
    {
      "en-US": "# Go TDD Command",
      "zh-Hans": "# Go TDD 命令"
    },
    {
      "en-US": "This command enforces test-driven development methodology for Go code using idiomatic Go testing patterns.",
      "zh-Hans": "此命令使用惯用的 Go 测试模式，为 Go 代码强制执行测试驱动开发方法。"
    },
    {
      "en-US": "## What This Command Does",
      "zh-Hans": "## 此命令的作用"
    },
    {
      "en-US": "1. **Define Types/Interfaces**: Scaffold function signatures first\n2. **Write Table-Driven Tests**: Create comprehensive test cases (RED)\n3. **Run Tests**: Verify tests fail for the right reason\n4. **Implement Code**: Write minimal code to pass (GREEN)\n5. **Refactor**: Improve while keeping tests green\n6. **Check Coverage**: Ensure 80%+ coverage",
      "zh-Hans": "1. **定义类型/接口**：首先搭建函数签名\n2. **编写表驱动测试**：创建全面的测试用例（红）\n3. **运行测试**：验证测试因正确的原因而失败\n4. **实现代码**：编写最少的代码以通过测试（绿）\n5. **重构**：在保持测试通过的同时进行改进\n6. **检查覆盖率**：确保 80% 以上的覆盖率"
    },
    {
      "en-US": "## When to Use",
      "zh-Hans": "## 何时使用"
    },
    {
      "en-US": "Use `/go-test` when:",
      "zh-Hans": "在以下情况下使用 `/go-test`："
    },
    {
      "en-US": "- Implementing new Go functions\n- Adding test coverage to existing code\n- Fixing bugs (write failing test first)\n- Building critical business logic\n- Learning TDD workflow in Go",
      "zh-Hans": "* 实现新的 Go 函数\n* 为现有代码添加测试覆盖\n* 修复错误（先编写失败的测试）\n* 构建关键业务逻辑\n* 学习 Go 中的 TDD 工作流程"
    },
    {
      "en-US": "## TDD Cycle",
      "zh-Hans": "## TDD 循环"
    },
    {
      "en-US": "```\nRED     → Write failing table-driven test\nGREEN   → Implement minimal code to pass\nREFACTOR → Improve code, tests stay green\nREPEAT  → Next test case\n```",
      "zh-Hans": "```\nRED     → Write failing table-driven test\nGREEN   → Implement minimal code to pass\nREFACTOR → Improve code, tests stay green\nREPEAT  → Next test case\n```"
    },
    {
      "en-US": "## Example Session",
      "zh-Hans": "## 示例会话"
    },
    {
      "en-US": "````\nUser: /go-test I need a function to validate email addresses\n\nAgent:\n# TDD Session: Email Validator\n\n## Step 1: Define Interface\n\n```go\n// validator/email.go\npackage validator\n\n// ValidateEmail checks if the given string is a valid email address.\n// Returns nil if valid, error describing the issue otherwise.\nfunc ValidateEmail(email string) error {\n    panic(\"not implemented\")\n}\n```\n\n## Step 2: Write Table-Driven Tests (RED)\n\n```go\n// validator/email_test.go\npackage validator\n\nimport (\n    \"testing\"\n)\n\nfunc TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        // Valid emails\n        {\"simple email\", \"user@example.com\", false},\n        {\"with subdomain\", \"user@mail.example.com\", false},\n        {\"with plus\", \"user+tag@example.com\", false},\n        {\"with dots\", \"first.last@example.com\", false},\n\n        // Invalid emails\n        {\"empty string\", \"\", true},\n        {\"no at sign\", \"userexample.com\", true},\n        {\"no domain\", \"user@\", true},\n        {\"no local part\", \"@example.com\", true},\n        {\"double at\", \"user@@example.com\", true},\n        {\"spaces\", \"user @example.com\", true},\n        {\"no tld\", \"user@example\", true},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := ValidateEmail(tt.email)\n            if tt.wantErr && err == nil {\n                t.Errorf(\"ValidateEmail(%q) = nil; want error\", tt.email)\n            }\n            if !tt.wantErr && err != nil {\n                t.Errorf(\"ValidateEmail(%q) = %v; want nil\", tt.email, err)\n            }\n        })\n    }\n}\n```\n\n## Step 3: Run Tests - Verify FAIL\n\n```bash\n$ go test ./validator/...\n\n--- FAIL: TestValidateEmail (0.00s)\n    --- FAIL: TestValidateEmail/simple_email (0.00s)\n        panic: not implemented\n\nFAIL\n```\n\n✓ Tests fail as expected (panic).\n\n## Step 4: Implement Minimal Code (GREEN)\n\n```go\n// validator/email.go\npackage validator\n\nimport (\n    \"errors\"\n    \"regexp\"\n)\n\nvar emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\nvar (\n    ErrEmailEmpty   = errors.New(\"email cannot be empty\")\n    ErrEmailInvalid = errors.New(\"email format is invalid\")\n)\n\nfunc ValidateEmail(email string) error {\n    if email == \"\" {\n        return ErrEmailEmpty\n    }\n    if !emailRegex.MatchString(email) {\n        return ErrEmailInvalid\n    }\n    return nil\n}\n```\n\n## Step 5: Run Tests - Verify PASS\n\n```bash\n$ go test ./validator/...\n\nPASS\nok      project/validator    0.003s\n```\n\n✓ All tests passing!\n\n## Step 6: Check Coverage\n\n```bash\n$ go test -cover ./validator/...\n\nPASS\ncoverage: 100.0% of statements\nok      project/validator    0.003s\n```\n\n✓ Coverage: 100%\n\n## TDD Complete!\n````",
      "zh-Hans": "````\nUser: /go-test I need a function to validate email addresses\n\nAgent:\n# TDD Session: Email Validator\n\n## Step 1: Define Interface\n\n```go\n// validator/email.go\npackage validator\n\n// ValidateEmail checks if the given string is a valid email address.\n// Returns nil if valid, error describing the issue otherwise.\nfunc ValidateEmail(email string) error {\n    panic(\"not implemented\")\n}\n```\n\n## Step 2: Write Table-Driven Tests (RED)\n\n```go\n// validator/email_test.go\npackage validator\n\nimport (\n    \"testing\"\n)\n\nfunc TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        // Valid emails\n        {\"simple email\", \"user@example.com\", false},\n        {\"with subdomain\", \"user@mail.example.com\", false},\n        {\"with plus\", \"user+tag@example.com\", false},\n        {\"with dots\", \"first.last@example.com\", false},\n\n        // Invalid emails\n        {\"empty string\", \"\", true},\n        {\"no at sign\", \"userexample.com\", true},\n        {\"no domain\", \"user@\", true},\n        {\"no local part\", \"@example.com\", true},\n        {\"double at\", \"user@@example.com\", true},\n        {\"spaces\", \"user @example.com\", true},\n        {\"no tld\", \"user@example\", true},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := ValidateEmail(tt.email)\n            if tt.wantErr && err == nil {\n                t.Errorf(\"ValidateEmail(%q) = nil; want error\", tt.email)\n            }\n            if !tt.wantErr && err != nil {\n                t.Errorf(\"ValidateEmail(%q) = %v; want nil\", tt.email, err)\n            }\n        })\n    }\n}\n```\n\n## Step 3: Run Tests - Verify FAIL\n\n```bash\n$ go test ./validator/...\n\n--- FAIL: TestValidateEmail (0.00s)\n    --- FAIL: TestValidateEmail/simple_email (0.00s)\n        panic: not implemented\n\nFAIL\n```\n\n✓ Tests fail as expected (panic).\n\n## Step 4: Implement Minimal Code (GREEN)\n\n```go\n// validator/email.go\npackage validator\n\nimport (\n    \"errors\"\n    \"regexp\"\n)\n\nvar emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}---\ndescription: 强制执行 Go 的 TDD 工作流程。先编写表格驱动测试，然后实现。使用 go test -cover 验证 80%+ 覆盖率。\n---\n\n# Go TDD 命令\n\n此命令使用惯用的 Go 测试模式，为 Go 代码强制执行测试驱动开发方法。\n\n## 此命令的作用\n\n1.  **定义类型/接口**：首先搭建函数签名\n2.  **编写表驱动测试**：创建全面的测试用例（红）\n3.  **运行测试**：验证测试因正确的原因而失败\n4.  **实现代码**：编写最少的代码以通过测试（绿）\n5.  **重构**：在保持测试通过的同时进行改进\n6.  **检查覆盖率**：确保 80% 以上的覆盖率\n\n## 何时使用\n\n在以下情况下使用 `/go-test`：\n\n*   实现新的 Go 函数\n*   为现有代码添加测试覆盖\n*   修复错误（先编写失败的测试）\n*   构建关键业务逻辑\n*   学习 Go 中的 TDD 工作流程\n\n## TDD 循环\n\n```\nRED     → Write failing table-driven test\nGREEN   → Implement minimal code to pass\nREFACTOR → Improve code, tests stay green\nREPEAT  → Next test case\n```\n\n## 示例会话\n\n)\n\nvar (\n    ErrEmailEmpty   = errors.New(\"email cannot be empty\")\n    ErrEmailInvalid = errors.New(\"email format is invalid\")\n)\n\nfunc ValidateEmail(email string) error {\n    if email == \"\" {\n        return ErrEmailEmpty\n    }\n    if !emailRegex.MatchString(email) {\n        return ErrEmailInvalid\n    }\n    return nil\n}\n```\n\n## Step 5: Run Tests - Verify PASS\n\n```bash\n$ go test ./validator/...\n\nPASS\nok      project/validator    0.003s\n```\n\n✓ All tests passing!\n\n## Step 6: Check Coverage\n\n```bash\n$ go test -cover ./validator/...\n\nPASS\ncoverage: 100.0% of statements\nok      project/validator    0.003s\n```\n\n✓ Coverage: 100%\n\n## TDD Complete!\n````"
    },
    {
      "en-US": "## Test Patterns",
      "zh-Hans": "## 测试模式"
    },
    {
      "en-US": "### Table-Driven Tests",
      "zh-Hans": "### 表驱动测试"
    },
    {
      "en-US": "```go\ntests := []struct {\n    name     string\n    input    InputType\n    want     OutputType\n    wantErr  bool\n}{\n    {\"case 1\", input1, want1, false},\n    {\"case 2\", input2, want2, true},\n}\n\nfor _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n        got, err := Function(tt.input)\n        // assertions\n    })\n}\n```",
      "zh-Hans": "```go\ntests := []struct {\n    name     string\n    input    InputType\n    want     OutputType\n    wantErr  bool\n}{\n    {\"case 1\", input1, want1, false},\n    {\"case 2\", input2, want2, true},\n}\n\nfor _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n        got, err := Function(tt.input)\n        // assertions\n    })\n}\n```"
    },
    {
      "en-US": "### Parallel Tests",
      "zh-Hans": "### 并行测试"
    },
    {
      "en-US": "```go\nfor _, tt := range tests {\n    tt := tt // Capture\n    t.Run(tt.name, func(t *testing.T) {\n        t.Parallel()\n        // test body\n    })\n}\n```",
      "zh-Hans": "```go\nfor _, tt := range tests {\n    tt := tt // Capture\n    t.Run(tt.name, func(t *testing.T) {\n        t.Parallel()\n        // test body\n    })\n}\n```"
    },
    {
      "en-US": "### Test Helpers",
      "zh-Hans": "### 测试辅助函数"
    },
    {
      "en-US": "```go\nfunc setupTestDB(t *testing.T) *sql.DB {\n    t.Helper()\n    db := createDB()\n    t.Cleanup(func() { db.Close() })\n    return db\n}\n```",
      "zh-Hans": "```go\nfunc setupTestDB(t *testing.T) *sql.DB {\n    t.Helper()\n    db := createDB()\n    t.Cleanup(func() { db.Close() })\n    return db\n}\n```"
    },
    {
      "en-US": "## Coverage Commands",
      "zh-Hans": "## 覆盖率命令"
    },
    {
      "en-US": "```bash\n# Basic coverage\ngo test -cover ./...\n\n# Coverage profile\ngo test -coverprofile=coverage.out ./...\n\n# View in browser\ngo tool cover -html=coverage.out\n\n# Coverage by function\ngo tool cover -func=coverage.out\n\n# With race detection\ngo test -race -cover ./...\n```",
      "zh-Hans": "```bash\n# Basic coverage\ngo test -cover ./...\n\n# Coverage profile\ngo test -coverprofile=coverage.out ./...\n\n# View in browser\ngo tool cover -html=coverage.out\n\n# Coverage by function\ngo tool cover -func=coverage.out\n\n# With race detection\ngo test -race -cover ./...\n```"
    },
    {
      "en-US": "## Coverage Targets",
      "zh-Hans": "## 覆盖率目标"
    },
    {
      "en-US": "| Code Type | Target |\n|-----------|--------|\n| Critical business logic | 100% |\n| Public APIs | 90%+ |\n| General code | 80%+ |\n| Generated code | Exclude |",
      "zh-Hans": "| 代码类型 | 目标 |\n|-----------|--------|\n| 关键业务逻辑 | 100% |\n| 公共 API | 90%+ |\n| 通用代码 | 80%+ |\n| 生成的代码 | 排除 |"
    },
    {
      "en-US": "## TDD Best Practices",
      "zh-Hans": "## TDD 最佳实践"
    },
    {
      "en-US": "**DO:**",
      "zh-Hans": "**要做：**"
    },
    {
      "en-US": "- Write test FIRST, before any implementation\n- Run tests after each change\n- Use table-driven tests for comprehensive coverage\n- Test behavior, not implementation details\n- Include edge cases (empty, nil, max values)",
      "zh-Hans": "* 在任何实现**之前**先编写测试\n* 每次更改后运行测试\n* 使用表驱动测试以获得全面的覆盖率\n* 测试行为，而非实现细节\n* 包含边界情况（空值、nil、最大值）"
    },
    {
      "en-US": "**DON'T:**",
      "zh-Hans": "**不要：**"
    },
    {
      "en-US": "- Write implementation before tests\n- Skip the RED phase\n- Test private functions directly\n- Use `time.Sleep` in tests\n- Ignore flaky tests",
      "zh-Hans": "* 在测试之前编写实现\n* 跳过红阶段\n* 直接测试私有函数\n* 在测试中使用 `time.Sleep`\n* 忽略不稳定的测试"
    },
    {
      "en-US": "## Related Commands",
      "zh-Hans": "## 相关命令"
    },
    {
      "en-US": "- `/go-build` - Fix build errors\n- `/go-review` - Review code after implementation\n- `/verify` - Run full verification loop",
      "zh-Hans": "* `/go-build` - 修复构建错误\n* `/go-review` - 实现后审查代码\n* `/verify` - 运行完整的验证循环"
    },
    {
      "en-US": "## Related",
      "zh-Hans": "## 相关"
    },
    {
      "en-US": "- Skill: `skills/golang-testing/`\n- Skill: `skills/tdd-workflow/`",
      "zh-Hans": "* 技能：`skills/golang-testing/`\n* 技能：`skills/tdd-workflow/`"
    }
  ]
}